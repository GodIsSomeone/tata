### 线程and进程
1. 信号的生命周期？  
2. 信号的产生方式？  
3. 信号处理方式？  
4. linux内部提供了那些调试宏？
5. 死锁的原因？条件？如何预防？又如何避免？如何解除？
6. 解决hash冲突的方法？
7. 进程与线程的区别？
8. 进程间的通信方式有哪些？线程间的通信方式呢？
9. 线程私有和共享那些资源？进程私有和共享那些资源？
10. 什么是守护进程？如何查看守护进程？什么是僵尸进程？如何查看僵尸进程？
11. 进程同步机制？
12. 什么是信号？
13. kill函数的每一个参数的作用？
14. 虚拟内存实现有哪几种方式？有什么意义？
15. 什么是类型安全？能举例吗？
16. 确保线程安全的几种方式？
17. Pthread_cond_signal和pthread_cond_broadcast的区别


### C++基本知识
1. 如何消除隐式转换？

[Explicit](https://www.cnblogs.com/bastard/archive/2012/02/09/2344425.html)

2. 重载，重写和隐藏的区别？
   + 函数重载：函数重载必须在同一个类中进行；子类无法重载父类函数，父类同名函数将被名称覆盖；重载是在编译器期间根据参数类型和个数决定函数调用(静态联编)。   
   + 函数重写：函数重写必须发生在父类与子类之间；父类与子类的函数原型完全一样；使用virtual声明之后能够产生多态(如果不写virtual关键字，称为重定义)；  
   + 多态是在运行期间根据具体对象的类型来决定函数调用  

3. volatile表示什么？有什么作用？
   + Volatile关键词的第一个特性：易变性。所谓的易变性，在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。  
   + Volatile关键词的第二个特性：“不可优化”特性。volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。  
   + Volatile关键词的第三个特性：”顺序性”，能够保证Volatile变量间的顺序性，编译器不会进行乱序优化。  
   + C/C++ Volatile变量，与非Volatile变量之间的操作，是可能被编译器交换顺序的。C/C++ Volatile变量间的操作，是不会被编译器交换顺序的。哪怕将所有的变量全部都声明为volatile，哪怕杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力，针对这个多线程的应用，真正正确的做法，是构建一个happens-before语义。 

4. Static_cast<>,dynamic_cast<>,const_cast<>,reinterpret_cast<>的各自作用和使用环境？


5. malloc和new的区别？
   1. new需要调用构造函数，malloc只是申请一块内存。  
   2. new不需要指定内存，malloc需要指定内存  
   3. new出来的类型固定，malloc出来的是void*  
   4. malloc出来的是在堆上内存，new出来的是自由存储区  
   5. new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。  
   6. 对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。 

6. free和delete的区别？
    delete调用析构函数，然后调用free。free直接释放

7. free一个数组时如何知道要释放多大的内存呢？
    + malloc是C/C++中的动态内存分配的标准库函数，函数原型：void* malloc(unsigned int size)；其功能就是在堆上动态开辟内存空间，它的特点： 
    1、返回值为void*，（void* 类型可以强制转换为任何其它类型的指针，但反过来就不行了）；  
    2、需要具体指定要分配空间的大小size，且size类型为无符整型；  
    3、它允许申请0个长度的内存（这点很有意思吧）；  
    4、其申请到的空间逻辑上是连续的，物理上是离散的（链表形式管理）。  
    在malloc分配了空间后，free释放空间的时候是怎么知道要free的空间的大小呢？  

    + 其实真正的内存管理如申请/释放等，并不是由malloc或者free等库函数来负责的，而是交由操作系统去完成，*它们只是维护一个空闲的链表式的内存块，理解这一点是问题的关键*。例如：要申请sizeof(int) x 100大小的内存空间，虽然返回的是内存大小是400，但实际上，*操作系统分配时候，会多出一块用于存储内存大小的类似链表head头节点的东西，这个节点存储的是空间的首地址及分配内存的大小。当用户调用free函数的时候，其实它也不知道要释放内存的大小，它只需改变head头结点里的内存的大小就可以了，具体内存空间的释放由操作系统去完成*。  

8. __stdcall和__cdecl的区别？


9. 引用和指针的区别？


10. 出现异常时，try和catch做了什么？


11. C++如何处理多个异常的？


12. 常对象的成员变量一定不可以修改吗？为什么？
13. 虚函数的调用过程？
14. 单继承，多继承，菱形继承，虚继承时，对象内存中的差异区别？如果存在虚函数呢？
15. C++分为内存分为哪几部分？
16. 如果new申请内存失败了，如何去解决？如果让你实现一个new，你会怎么实现？
17. 如何得到一个结构体内成员的偏移量？
18. 为什么要字节对齐？
19. 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？
20. 如果在构造函数中调用memset(this, 0, sizeof(*this))来初始化内存空间，有什么问题吗？
21. 对一个数组而言，delete a和delete[] a有什么区别？为什么？
22. Dynamic_cast是如何实现运行时类型转换的？
23. C语言调用C++语法函数怎么做？那C++调用C语法的函数怎么做？
24. Extern “C”是什么意思？他有什么作用？
25. 静态函数能定义为虚函数吗？为什么？
26. 对于默认处理的结构体，能用memcmp来进行比较吗？为什么？如果不能，该如何比较？
27. Struct{char a[0];}的作用？有什么好处？
28. 如何判断两个浮点数相等？
29. 浮点数为什么会有误差？
30. 栈上分配内存和堆上分配内存有什么区别？
31. 变量的存储方式有哪些？
32. 虚函数表是在什么时候确定的？那虚表指针呢？
33. C++中有哪些机制可以取代宏？
34. 系统调用与函数调用的区别？
35. 手写一个有可变参数的函数？
36. this指针调用成员变量时，堆栈会发生什么变化？
37. 实现一个shared_ptr类和auto_ptr类
38. C++中可以继承string类吗？为什么？
39. Char * const *(*next)()是什么？
40. 如何判断const所修饰的对象？
41. 构造函数能不能虚函数？为什么？那拷贝构造函数能不能为虚函数？为什么？
42. 析构函数能不能虚函数？为什么？
43. 模板和实现可不可以不写在一个文件里面？为什么？
44. 什么是RAII资源管理？
45. 如何检查内存泄露？如果不通过printf,debug等调试方式和编译器报错提示呢？
46. Int(*f(int,void(*)()))(int,int)是什么意思？


### STL
1. 实现一个vector？是1.5还是2倍，各有什么优缺点？
2. map底层用了什么？
3. 如果用map删除了一个元素，迭代器还能用吗？为什么？怎样做可以接着用？
4. STL空间配置器如何处理内存的？能说一下它的大概实现方案吗？为什么是8bytes的倍数？

### 数据结构
1. 红黑树的特征是什么？
2. 红黑树如何插入和删除的？
3. 红黑树和B+,B-的区别？
4. 线程同步几种方式？


### 算法
1. 手写strcpy,memcpy,memmove函数？
2. Do{}while(0)的用法有哪些？
3. 手写快排？时间复杂度？空间复杂度？能进行优化吗？还有吗？能进行尾递归优化吗？
4. 线程池的作用是什么？
5. 逐层打印二叉树？
6. 排序稳定的算法，你知道那些？
7. 手写线程安全的单例模式？



### 计算机网络
1. OSI七层模型？
2. TCP/IP五层模型？
3. DHCP协议是什么？使用什么端口？他的优劣？
4. 网络序是大端还是小端？为什么要这样？
5. ping命令使用的是什么协议？
6. 路由表一般包含什么？
7. 停止等待协议的缺点？为什么？
8. 拥塞控制的方式？具体怎么做的？快重传的时机是什么？
9. DNS协议如何实现将域名解析为IP地址的？
10. 创建进程的步骤？
11. 进程切换发生的原因？处理进程切换的步骤？
12. TCP三次握手和四次挥手及各自的状态？
13. TCP如果两次握手会出什么问题？那三次握手又会造成什么问题？有什么好的解决方法没？
14. TCP四次挥手为什么要有TIME_WAIT状态？为什么？

