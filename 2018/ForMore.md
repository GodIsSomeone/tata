# 一些零碎的知识点 
## new 和 malloc的区别
1.new需要调用构造函数，malloc只是申请一块内存。<br>
2.new不需要指定内存，malloc需要指定内存<br>
3.new出来的类型固定，malloc出来的是void*<br>
4.malloc出来的是在堆上内存，new出来的是自由存储区<br>
5.new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。<br>

## 牛客   
1.编译过程是：预编译--编译--汇编--链接。其中编译阶段是生成汇编代码（.s文件），要生成目标代码（.o）需要经过汇编后才生成；   
2.访问虚函数，必须有对象的存在。原因：对象中存放虚函数表指针。因为虚函数本质上是通过类对象的虚表进行访问，而且类的成员函数除了虚函数，其他都不存储在类当中，因此类对象不存在的情况下，无法使用虚函数，其他函数都可以正常访问（前提是这些函数都没有存取类对象的成员变量）   
3.switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型   
4. auto会忽略顶层const，所以b的类型为int， 如果表达式的内容是解引用操作，则decltype将得到引用类型。   
5.无论是float还是double，在内存中的存储分为三部分，符号位，指数位，尾数位，位运算符对他们没有意义
6.引用和指针的区别。引用不为空，依附于别的值存在，指针可为空，引用不能重新定义，指针可以见异思迁。

## 多态   

### 1.为什么会有多态的需求：怎么样才能解决，传入子类对象调用子类函数，传入基类对象调用基类函数呢？   
　　多态：就是根据实际的对象类型 决定 函数调用语句的具体调用目标。总结一句话就是，同样的调用语句有多种不同的表现形态。      
### 2.C++编译器是如何实现上述需求的呢？   
   基类与子类的同名函数，要想实现多态，基类同名函数必须声明为virtual函数。 要有继承，要有虚函数重写，父类指针(引用)指向子类对象。     
### 3.静态联编和动态联编      
   静态联编：静态联编是指联编工作在编译阶段完成的，这种联编过程是在程序运行之前完成的，又称为早期联编。要实现静态联编，在编译阶段就必须确定程序中的操作调用（如函数调用）与执行该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引用的类型。其优点是效率高，但灵活性差。    
   动态联编：动态联编是指联编在程序运行时动态地进行，根据当时的情况来确定调用哪个同名函数，实际上是在运行时虚函数的实现。这种联编又称为晚期联编，或动态束定。动态联编对成员函数的选择是基于对象的类型，针对不同的对象类型将做出不同的编译结果。C++中一般情况下的联编是静态联编，但是当涉及到多态性和虚函数时应该使用动态联编。动态联编的优点是灵活性强，但效率低。 动态联编规定，只能通过指向基类的指针或基类对象的引用来调用虚函数，其格式为：指向基类的指针变量名->虚函数名（实参表）或基类对象的引用名.虚函数名（实参表）             

### 4.重载，重写，重定义   
  函数重载：函数重载必须在同一个类中进行；子类无法重载父类函数，父类同名函数将被名称覆盖；重载是在编译器期间根据参数类型和个数决定函数调用(静态联编)。   
  函数重写：函数重写必须发生在父类与子类之间；父类与子类的函数原型完全一样；使用virtual声明之后能够产生多态(如果不写virtual关键字，称为重定义)；多态是在运行期间根据具体对象的类型来决定函数调用    
### 5.编译器在什么地方动了手脚，从而支持了多态？     
  真正确定绑定关系的地方，就是创建对象的时候！！这时候C++编译器会偷偷的给对象添加一个vptr指针。 
　只要我们在类中定义了virtual函数，那么我们在定义对象的时候，C++编译器会在对象中存储一个vptr指针，类中创建的虚函数的地址会存放在一个虚函数表中，vptr指针就是指针這个表的首地址。     
  在发生多态的地方，也就上面的，编译器根本不会去区分，传进来的是子类对象还是父类对象。而是关心print()是否为虚函数，如果是虚函数，就根据不同对象的vptr指针找属于自己的函数。而且父类对象和子类对象都会有vptr指针，传入对象不同，编译器会根据vptr指针，到属于自己虚函数表中找自己的函数。即：vptr--->虚函数表------>函数的入口地址，从而实现了迟绑定(在运行的时候，才会去判断)。     
  如果不是虚函数，那么这种绑定关系在编译的时候就已经确定的，也就是静态联编！      
  说明1：通过虚函数表指针VPTR调用重写函数是在程序运行时进行的，因此需要通过寻址操作才能确定真正应该调用的函数。而普通成员函数是在编译时就确定了调用的函数。在效率上，虚函数的效率要低很多。  
  说明2：出于效率考虑，没有必要将所有成员函数都声明为虚函数     
  说明3 ：C++编译器，执行play函数，不需要区分是子类对象还是父类对象     
  
### 6.多态的实现原理     
  说明1：通过虚函数表指针VPTR调用重写函数是在程序运行时进行的，因此需要通过寻址操作才能确定真正应该调用的函数。而普通成员函数是在编译时就确定了调用的函数。在效率上，虚函数的效率要低很多。     
  说明2：出于效率考虑，没有必要将所有成员函数都声明为虚函数        
  说明3 ：C++编译器，执行play函数，不需要区分是子类对象还是父类对象          
  
### 7.构造函数中能调用虚函数，实现多态么？     
  不会发生多态。当定义一个子类对象的时候比较麻烦，因为构造子类对象的时候会首先调用父类的构造函数然后再调用子类的构造函数。当调用父类的构造函数的时候，此时会创建Vptr指针（也可以认为Vptr指针是属于父类的成员，所以在子类中重写虚函数的时候virtual关键字可以省略，因为编译器会识别父类有虚函数，然后就会生成Vptr指针变量），该指针会指向父类的虚函数表；然后再调用子类的构造函数，此时Vptr又被赋值指向子类的虚函数表。          
 （执行父类的构造函数的时候Vptr指针指向的是父类的虚函数表，所以只能执行父类的虚函数）         
