# 一些零碎的知识点 
## new 和 malloc的区别
1.new需要调用构造函数，malloc只是申请一块内存。<br>
2.new不需要指定内存，malloc需要指定内存<br>
3.new出来的类型固定，malloc出来的是void*<br>
4.malloc出来的是在堆上内存，new出来的是自由存储区<br>
5.new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。<br>
6.对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。      

## 牛客   
1.编译过程是：预编译--编译--汇编--链接。其中编译阶段是生成汇编代码（.s文件），要生成目标代码（.o）需要经过汇编后才生成；   
2.访问虚函数，必须有对象的存在。原因：对象中存放虚函数表指针。因为虚函数本质上是通过类对象的虚表进行访问，而且类的成员函数除了虚函数，其他都不存储在类当中，因此类对象不存在的情况下，无法使用虚函数，其他函数都可以正常访问（前提是这些函数都没有存取类对象的成员变量）   
https://www.tuicool.com/articles/iUB3Ebi          

3.switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型   
4. auto会忽略顶层const，所以b的类型为int， 如果表达式的内容是解引用操作，则decltype将得到引用类型。   
5.无论是float还是double，在内存中的存储分为三部分，符号位，指数位，尾数位，位运算符对他们没有意义
6.引用和指针的区别。引用不为空，依附于别的值存在，指针可为空，引用不能重新定义，指针可以见异思迁。

## 多态   

### 1.为什么会有多态的需求：怎么样才能解决，传入子类对象调用子类函数，传入基类对象调用基类函数呢？   
　　多态：就是根据实际的对象类型 决定 函数调用语句的具体调用目标。总结一句话就是，同样的调用语句有多种不同的表现形态。      
### 2.C++编译器是如何实现上述需求的呢？   
   基类与子类的同名函数，要想实现多态，基类同名函数必须声明为virtual函数。 要有继承，要有虚函数重写，父类指针(引用)指向子类对象。     
### 3.静态联编和动态联编      
   静态联编：静态联编是指联编工作在编译阶段完成的，这种联编过程是在程序运行之前完成的，又称为早期联编。要实现静态联编，在编译阶段就必须确定程序中的操作调用（如函数调用）与执行该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引用的类型。其优点是效率高，但灵活性差。    
   动态联编：动态联编是指联编在程序运行时动态地进行，根据当时的情况来确定调用哪个同名函数，实际上是在运行时虚函数的实现。这种联编又称为晚期联编，或动态束定。动态联编对成员函数的选择是基于对象的类型，针对不同的对象类型将做出不同的编译结果。C++中一般情况下的联编是静态联编，但是当涉及到多态性和虚函数时应该使用动态联编。动态联编的优点是灵活性强，但效率低。 动态联编规定，只能通过指向基类的指针或基类对象的引用来调用虚函数，其格式为：指向基类的指针变量名->虚函数名（实参表）或基类对象的引用名.虚函数名（实参表）             

### 4.重载，重写，重定义   
  函数重载：函数重载必须在同一个类中进行；子类无法重载父类函数，父类同名函数将被名称覆盖；重载是在编译器期间根据参数类型和个数决定函数调用(静态联编)。   
  函数重写：函数重写必须发生在父类与子类之间；父类与子类的函数原型完全一样；使用virtual声明之后能够产生多态(如果不写virtual关键字，称为重定义)；多态是在运行期间根据具体对象的类型来决定函数调用    
### 5.编译器在什么地方动了手脚，从而支持了多态？     
  真正确定绑定关系的地方，就是创建对象的时候！！这时候C++编译器会偷偷的给对象添加一个vptr指针。 
　只要我们在类中定义了virtual函数，那么我们在定义对象的时候，C++编译器会在对象中存储一个vptr指针，类中创建的虚函数的地址会存放在一个虚函数表中，vptr指针就是指针這个表的首地址。     
  在发生多态的地方，也就上面的，编译器根本不会去区分，传进来的是子类对象还是父类对象。而是关心print()是否为虚函数，如果是虚函数，就根据不同对象的vptr指针找属于自己的函数。而且父类对象和子类对象都会有vptr指针，传入对象不同，编译器会根据vptr指针，到属于自己虚函数表中找自己的函数。即：vptr--->虚函数表------>函数的入口地址，从而实现了迟绑定(在运行的时候，才会去判断)。     
  如果不是虚函数，那么这种绑定关系在编译的时候就已经确定的，也就是静态联编！      
  说明1：通过虚函数表指针VPTR调用重写函数是在程序运行时进行的，因此需要通过寻址操作才能确定真正应该调用的函数。而普通成员函数是在编译时就确定了调用的函数。在效率上，虚函数的效率要低很多。  
  说明2：出于效率考虑，没有必要将所有成员函数都声明为虚函数     
  说明3 ：C++编译器，执行play函数，不需要区分是子类对象还是父类对象     
  
### 6.多态的实现原理     
  说明1：通过虚函数表指针VPTR调用重写函数是在程序运行时进行的，因此需要通过寻址操作才能确定真正应该调用的函数。而普通成员函数是在编译时就确定了调用的函数。在效率上，虚函数的效率要低很多。     
  说明2：出于效率考虑，没有必要将所有成员函数都声明为虚函数        
  说明3 ：C++编译器，执行play函数，不需要区分是子类对象还是父类对象          
  
### 7.构造函数中能调用虚函数，实现多态么？     
  不会发生多态。当定义一个子类对象的时候比较麻烦，因为构造子类对象的时候会首先调用父类的构造函数然后再调用子类的构造函数。当调用父类的构造函数的时候，此时会创建Vptr指针（也可以认为Vptr指针是属于父类的成员，所以在子类中重写虚函数的时候virtual关键字可以省略，因为编译器会识别父类有虚函数，然后就会生成Vptr指针变量），该指针会指向父类的虚函数表；然后再调用子类的构造函数，此时Vptr又被赋值指向子类的虚函数表。          
 （执行父类的构造函数的时候Vptr指针指向的是父类的虚函数表，所以只能执行父类的虚函数）         

## 内存
   
   ### 内存的种类
   在c++中，共有五种内存，栈、堆、自由存储区、全局/静态存储区、常量存储区。    
   栈中存储一些局部变量，在作用区域结束后，被程序释放掉。       
   堆中存储一些new出来的变量，自己new，自己delete。    
   自由存储区，malloc出来的。自己free。     
   全局/静态存储区，常量存储区， 顾名思义    
   ### 堆内存和栈内存的区别    
   1.栈内存由系统分配，系统负责管理，栈内存由开发者进行管理，容易发生内存泄漏   
   2.空间大小不同，堆内存一般可以打到4G（32系统），栈内存一般较小（可以修改）    
   3.碎片问题，堆内存频繁的new/delete会影响程序的效率，栈内存则不会，清空操作的时候，后进先出，已经清理完毕了。    
   4.生长方向，堆内存是向着地址逐渐增大的方向，栈内存是向着地址逐渐变小的方向。           
   5.分配效率，栈内存由计算机系统底层进行指令支持，效率要高一些；堆内存有c++函数库进行支持，按照大小进行空间搜索进行分配，如果没有足够大的空间，则向系统申请空间。    
   ### 常见内存错误    
   1.内存没有申请成功，却使用了他      
   2.内存申请成功，却没有初始化。         
   3.内存越界。     
   4.忘记释放内存，或者释放内存后继续使用。         
   ### extern“C”       
   为了正确的在c++中调用C的函数，因为在C中编译的库和在C++中编译后的名称是不一样的。加上extern“C”后表示是按照C的规则进行编译。C++支持函数重载，而C语言不支持，C++在编译的时候会带上参数和类型，C中编译只会带上函数名。应用场景是C++调用C的库。     
   ### TCP 和 UDP之间的区别   
   ？？？？？    
   ### volatile     
   类型修饰符，用volatile修饰的变量，编译器不再进行相关的优化，提供稳定的地址进行存储。volatile修饰的变量，系统每次都去都会去地址读取，而一般的比如int b = a;系统发现多次读取b的值且没有发生变化，就会把a的值直接放在b的地址里，而不是再从a里边去读取。如果a是寄存器的地址或者是一个端口数据，就容易出错。volatile可以保证对特殊地址的稳定访问。       
   ### 内联函数和宏定义的区别    
   内联函数是在编译期进行参数检查、替代，宏定义是在预编译期间进行替代。（预编译就是处理以#开头的定义，为编译进行准备工作）内联函数可以作为类中的成员函数，调用保护变量和私有变量。内联函数是函数，可以调用其他函数。     
   ### 字节对齐   
   现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际情况上，在访问特定类型变量的时候经常在特定的内存地址访问，这就是需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。   
   平台的原因：不是所有的平台都是任意的访问数据的，某些硬件平台只能在某些地址处取某些数据 ，否则抛异常。     
   性能的原因：数据结构应该尽可能地再自然边界上对齐，原因在于为了访问未对齐的内存，处理器需要做两次访问内存，而对齐的内存访问只需要一次访问。    
           
   指针、多态（虚函数表、内存 layout等）、作用域、内存的管理          
   ### vector增长模式        
   size()函数返回的是已用空间大小，capacity()返回的是总空间大小，capacity()-size()则是剩余的可用空间大小。当size()和capacity()相等，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。reserve(n)预先分配一块较大的指定大小的内存空间，其中n为分配空间大小；resize()成员函数只改变元素的数目，不改变vector的容量。     
    再看刚刚的运行结果，首先可以确定，在VS2010的编译器里面每次并不是增长固定的内存，可以看出是增长当前内存的一半。而且由于我们的程序没有调用reserve（n）函数预先分配一块内存，所以内存增长是编译器自动完成的。这个自动增长包括重新分配内存空间、拷贝原空间、释放原空间三个过程，具体策略为当添加元素时，如果vector空间大小不足，则会以原大小的1.5倍另外配置一块较大的新空间，然后将原空间内容拷贝过来，在新空间的内容末尾添加元素，并释放原空间。也就是说vector的空间动态增加大小，并不是在原空间之后的相邻地址增加新空间，因为vector的空间是线性连续分配的，不能保证原空间之后有可供配置的空间。这就解释了上述程序的运行结果。       
    但是，针对以上自动完成的内存增长过程，由于包括重新分配内存空间、拷贝原空间、释放原空间等步骤，这些过程会降低程序效率，因此可以使用reserve(n)预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。          
   
   ### 各种容器之间的区别    
   vector：像数组一样，快速访问任何一个随机的元素，快速的再末尾插入元素，但是在序列中间插入以及删除要素比较慢，一开始分配的空间如果太小的话，重新分配，则拷贝的性能开销很大。   
   deque：连续的内存区域，支持高效的首部插入和删除元素。    
   list：非连续的内存区域，插入和删除效率高，随机访问支持不好。     
   vector和数组之间的关系：数组的维度必须是常量表达式，初始化的时候必须给出。数组不允许拷贝和赋值，即不能将数组的内容拷贝到其他数组作为其初始值，但是vector可以。数组使用的过程容易产生数组越界，而相对于vector则可以使用较多的机制来控制，例如使用迭代器。   
   
   2. 虚函数表
   
   
   3.函数指针复杂形式的识别
   4.HASH的设计
   5.几个常用工具的使用，gdb,gcc,git       
   6.vector list的原理       
   
   多线程相关，多线程主要问高并发、通信，然后还有锁相关的东西   
