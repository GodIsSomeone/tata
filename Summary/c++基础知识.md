
### C++基本知识
1. 如何消除隐式转换？

[Explicit](https://www.cnblogs.com/bastard/archive/2012/02/09/2344425.html)

2. 重载，重写和多态的区别？
   + 函数重载：函数重载必须在**同一个类**中进行；子类无法重载父类函数，父类同名函数将被名称覆盖；重载是在编译器期间根据参数类型和个数决定函数调用(静态联编)。   
   + 函数重写：函数重写必须发生在**父类与子类**之间；父类与子类的函数原型完全一样；使用virtual声明之后能够产生多态(如果不写virtual关键字，称为重定义)；  
   + 多态是在运行期间根据具体对象的类型来决定函数调用  

3. volatile表示什么？有什么作用？
   + Volatile关键词的第一个特性：易变性。所谓的易变性，在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。  
   + Volatile关键词的第二个特性：“不可优化”特性。volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。  
   + Volatile关键词的第三个特性：“顺序性”，能够保证Volatile变量间的顺序性，编译器不会进行乱序优化。  
   + C/C++ Volatile变量，与非Volatile变量之间的操作，是可能被编译器交换顺序的。C/C++ Volatile变量间的操作，是不会被编译器交换顺序的。哪怕将所有的变量全部都声明为volatile，哪怕杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力，针对这个多线程的应用，真正正确的做法，是构建一个happens-before语义。  

4. Static_cast<>,dynamic_cast<>,const_cast<>,reinterpret_cast<>的各自作用和使用环境？


5. malloc和new的区别？
   + new需要调用构造函数，malloc只是申请一块内存。  
   + new不需要指定内存，malloc需要指定内存  
   + new出来的类型固定，malloc出来的是void*  
   + malloc出来的是在堆上内存，new出来的是自由存储区  
   + new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。**所以对申请情况的判断也不一样**  
   + 对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。  

6. free和delete的区别？
    delete调用析构函数，然后调用free。free直接释放

7. free一个数组时如何知道要释放多大的内存呢？
    + malloc是C/C++中的动态内存分配的标准库函数，函数原型：void* malloc(unsigned int size)；其功能就是在堆上动态开辟内存空间，它的特点：  
     
      + 返回值为void*，（void* 类型可以强制转换为任何其它类型的指针，但反过来就不行了）；  
      + 需要具体指定要分配空间的大小size，且size类型为无符整型（unsigned int）；  
      + 它允许申请0个长度的内存（这点很有意思吧）；  
      + 其申请到的空间逻辑上是连续的，物理上是离散的（链表形式管理）。  

    在malloc分配了空间后，free释放空间的时候是怎么知道要free的空间的大小呢？  

    + 其实真正的内存管理如申请/释放等，并不是由malloc或者free等库函数来负责的，而是交由操作系统去完成，**它们只是维护一个空闲的链表式的内存块，理解这一点是问题的关键**。例如：要申请sizeof(int) x 100大小的内存空间，虽然返回的是内存大小是400，但实际上，**操作系统分配时候，会多出一块用于存储内存大小的类似链表head头节点的东西，这个节点存储的是空间的首地址及分配内存的大小。当用户调用free函数的时候，其实它也不知道要释放内存的大小，它只需改变head头结点里的内存的大小就可以了，具体内存空间的释放由操作系统去完成**。  

8. __stdcall和__cdecl的区别？
    + 采用__cdecl约定时，函数参数按照从右到左的顺序入栈，并且由调用函数者把参数弹出栈以清理堆栈。因此，实现可变参数的函数只能使用该调用约定。由于每一个使用__cdecl约定的函数都要包含清理堆栈的代码，所以产生的可执行文件大小会比较大。
    + 采用__stdcall约定时，函数参数按照从右到左的顺序入栈，被调用的函数在返回前清理传送参数的栈，函数参数个数固定。由于函数体本身知道传进来的参数个数，因此被调用的函数可以在返回前用一条ret n指令直接清理传递参数的堆栈。

9. 引用和指针的区别？
    + 指针可以为空，引用不能为空。
    + 引用不能改变引用对象，至死不渝，但是能改变引用的值；指针可以随便乱指。
    + 引用的大小是引用对象的大小；指针大小就是4或者8。

10. 出现异常时，try和catch做了什么？
    
+ 搜不到
    
11. C++如何处理多个异常的？
    
+ 搜不到
    
12. 常对象的成员变量一定不可以修改吗？为什么？
    + 常对象中所有的成员变量的值都不能被修改
    + 常对象访问函数时只能访问常成员函数；

13. 虚函数的调用过程？
    13.1 编译器在什么地方动了手脚，从而支持了多态？  
    真正确定绑定关系的地方，就是创建对象的时候！！这时候C++编译器会偷偷的给对象添加一个vptr指针。  
    在发生多态的地方，编译器根本不会去区分传进来的是子类对象还是父类对象。而是关心print()是否为虚函数，如果是虚函数，就根据不同对象的vptr指针找属于自己的函数。而且父类对象和子类对象都会有vptr指针，传入对象不同，编译器会根据vptr指针，到属于自己虚函数表中找自己的函数。即：vptr--->虚函数表------>函数的入口地址，从而实现了迟绑定(在运行的时候，才会去判断)。  

    如果不是虚函数，那么这种绑定关系在编译的时候就已经确定的，也就是**静态联编**！
  
    13.2 多态的实现原理  
    + 说明1：通过虚函数表指针VPTR调用重写函数是在程序运行时进行的，因此需要通过寻址操作才能确定真正应该调用的函数。而普通成员函数是在编译时就确定了调用的函数。在效率上，虚函数的效率要低很多。  
    + 说明2：出于效率考虑，没有必要将所有成员函数都声明为虚函数  
    + 说明3：C++编译器，执行play函数，不需要区分是子类对象还是父类对象  
  
14. 单继承，多继承，菱形继承，虚继承时，对象内存中的差异区别？如果存在虚函数呢？
    虚继承内存多一个虚函数指针，指向虚函数表。

15. C++分为内存分为哪几部分？
    在c++中，共有五种内存。**栈、堆、自由存储区、全局/静态存储区、常量存储区**。  
    栈中：存储一些局部变量，在作用区域结束后，被程序释放掉。  
    堆中：存储一些new出来的变量，自己new，自己delete。  
    自由存储区：malloc出来的，自己free。  
    全局/静态存储区，常量存储区  

    15.1 堆内存和栈内存的区别  
    + 栈内存由系统分配，系统负责管理，堆内存由开发者进行管理，容易发生内存泄漏  
    + 空间大小不同，堆内存一般可以达到4G（32系统），栈内存一般较小（可以修改）  
    + 碎片问题，堆内存频繁的new/delete会影响程序的效率，栈内存则不会，清空操作的时候，后进先出，已经清理完毕了。  
    + 生长方向，堆内存是向着地址逐渐增大的方向，栈内存是向着地址逐渐变小的方向。  
    + 分配效率，栈内存由计算机系统底层进行指令支持，效率要高一些；堆内存有c++函数库进行支持，按照大小进行空间搜索进行分配，如果没有足够大的空间，则向系统申请空间。  

    15.2 常见内存错误  
    + 内存没有申请成功，却使用了他  
    + 内存申请成功，却没有初始化。  
    + 内存越界。  
    + 忘记释放内存，或者释放内存后继续使用。

16. 如果new申请内存失败了，如何去解决？如果让你实现一个new，你会怎么实现？
    + 对于new出来的对象指针来说，其实，if ( p == 0 ) 完全是没啥意义的。C++ 里，如果 new 分配内存失败，默认是抛出异常的。所以，如果分配成功，p == 0 就绝对不会成立；
    + 而如果分配失败了，也不会执行 if ( p == 0 )，**因为分配失败时，new 就会抛出异常跳过后面的代码。如果你想检查 new 是否成功，应该捕捉异常**。  

+ malloc 的写法  
  ```
  char* buffer = (char*)malloc(1024); 
  if(buffer)
  {
      printf("malloc success!\r\n"); 
  }
  free(buffer);
  ```

+ new的写法  
  ```
  try
   { 
       char* buffer = new char[1024]; 
   } 
   catch(...)
   { 
       printf("operator new error!\r\n"); 
   } 
   delete []buffer;
  ```


17. 如何得到一个结构体内成员的偏移量？
    
18. 为什么要字节对齐？
    现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际情况上，在访问特定类型变量的时候经常在特定的内存地址访问，这就是需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。  
    平台的原因：不是所有的平台都是任意的访问数据的，某些硬件平台只能在某些地址处取某些数据 ，否则抛异常。  
    性能的原因：数据结构应该尽可能地在自然边界上对齐，原因在于为了访问未对齐的内存，处理器需要做两次访问内存，而对齐的内存访问只需要一次访问。  

19. 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？
    + delete this之后，不能再使用this访问对象及成员变量及虚函数。delete this回收的是数据，这包括对象的数据成员以及vtable，不包括函数代码  
    + this对象是必须是用 new操作符分配的（而不是用new[]，也不是用placement new，也不是局部对象，也不是global对象）；  

20. 如果在构造函数中调用memset(this, 0, sizeof(*this))来初始化内存空间，有什么问题吗？

+ 如果基类A存在虚函数，类B是这个基类的子类，在类B的构造函数体内仅仅调用memset(this,0,sizeof(*this));那么此操作会将虚表指针的值置为0，则无法索引到虚函数表，因此无法使用虚函数机制，即指向子类对象的基类指针或引用调用虚函数，在程序运行期间此时无法确定调用虚函数的版本。
    
21. 对一个数组而言，delete a和delete[] a有什么区别？为什么？
    + 针对简单类型 使用new分配后的不管是数组还是非数组形式内存空间用两种方式均可.
        ```
        int *a = new int[10];
        delete a;
        delete [] a;
        ```
    此种情况中的释放效果**相同**，原因在于：分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数，它直接通过指针可以获取实际分配的内存空间，哪怕是一个数组内存空间(在分配过程中 系统会记录分配内存的大小等信息，此信息保存在结构体_CrtMemBlockHeader中)  
    + 针对类Class，两种方式体现出具体差异
        ```
        class A{};
        A *a = new A[10];
        delete a;
        delete[] a;
        ```
      
      + delete a; 仅释放了a指针指向的全部内存空间，但是只调用了a[0]对象的析构函数，剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放，从而造成内存泄漏  
      + delete [] a; 调用使用类对象的析构函数释放用户自己分配内存空间并且释放了a指针指向的全部内存空间  

22. Dynamic_cast是如何实现运行时类型转换的？


23. C语言调用C++语法函数怎么做？那C++调用C语法的函数怎么做？
    
+ extern “C”
    
24. Extern “C”是什么意思？他有什么作用？
    在C语言中，修饰符extern用在变量或者函数的声明前，用来说明**此变量/函数是在别处定义的，要在此处引用**。  

    注意extern声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，为啥要用extern？**因为用extern会加速程序的编译过程，这样能节省时间**。  

    在C++中extern还有另外一种作用，用于指示C或者C＋＋函数的调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，**告诉链接器在链接的时候用C函数规范来链接**。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。  

25. 静态函数能定义为虚函数吗？为什么？
    + **static成员不属于任何类对象或类实例**，所以即使给此函数加上virutal也是没有任何意义的。
    + 静态与非静态成员函数之间有一个主要的区别。那就是**静态成员函数没有this指针**。

26. 对于默认处理的结构体，能用memcmp来进行比较吗？为什么？如果不能，该如何比较？
    可以通过memcmp()来比较2个相同的结构体变量，但这2个变量必须在赋值前进行清零初始化（否则结果不准确） ，或者2者是通过直接对等赋值而来。  

27. Struct{char a[0];}的作用？有什么好处？


28. 如何判断两个浮点数相等？
    用"=="来比较两个double应该相等的类型，返回真值完全是不确定的。计算机对浮点数的进行计算的原理是只保证必要精度内正确即可。  
    我们在判断浮点数相等时，推荐用范围来确定，若x在某一范围内，我们就认为相等，至于范围怎么定义，要看实际情况而已了，float,和double 各有不同  
    所以  
    const float EPSINON = 0.00001;  
    if((x >= - EPSINON) && (x <= EPSINON)  
    这样判断是可取的至于为什么取0.00001，可以自己按实际情况定义。  
    ```
    const foat EPSINON = 0.000001;
    float A = 80.43323,B = 80.433199;
    float x = A - B;
    if ((x >= - EPSINON)&& (x <= EPSINON)
        cout<<"A 与B相等"<<endl;
    else
        cout<<"不相等"<<endl;
    ```

29. 变量的存储方式有哪些？
    + 变量可以分为全局变量、静态全局变量、静态局部变量和局部变量
    + 按存储区域分：全局变量、静态全局变量和静态局部变量都存放在内存的全局数据区，局部变量存放在内存的栈区
    + 按作用域分：全局变量在整个工程文件内都有效；静态全局变量只在定义它的文件内有效；静态局部变量只在定义它的函数内有效，只是程序仅分配一次内存，函数返回后，该变量不会消失；局部变量在定义它的函数内有效，但是函数返回后失效。
    + 全局变量和静态变量如果没有手工初始化，则由编译器初始化为0。**局部变量的值不可知**。  

30. 虚函数表是在什么时候确定的？那虚表指针呢？
    构造函数调用的时候创建虚表指针；编译的时候创建虚函数表。

31. C++中有哪些机制可以取代宏？
    内联函数、const等

32. 系统调用与函数调用的区别？

33. this指针调用成员变量时，堆栈会发生什么变化？
    将相应的参数从右往左压栈，然后将this指针放到寄存器中  

34. C++中可以继承string类吗？为什么？
    不可以。因为string是模板，不是类  

35. Char * const *(*next)()是什么？
    next是一个指针，指向一个函数，这个函数返回一个指针，这个指针指向char类型的常量指针  

36. 如何判断const所修饰的对象？
    const只修饰其后的【变量】，至于const放在类型前还是类型后并没有区别

37. 构造函数能不能虚函数？为什么？那拷贝构造函数能不能为虚函数？为什么？
    从存储空间角度，虚函数对应一个指向vtable虚函数表的指针，这大家都知道，可是这个指向vtable的指针其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。  
    **其实可以利用虚函数的机制来实现上述功能**!正儿八经的来说，还是不允许构造函数或者拷贝构造函数声明为虚函数的。  
    [论虚构造函数与虚复制构造函数的实现](https://blog.csdn.net/dicky3651/article/details/5421662)  
    下文来自<< more effective c++ >>:
    > 正如我们看到的，类的虚拟拷贝构造函数只是调用它们真正的拷贝构造函数。因此“拷贝”的含义与真正的拷贝构造函数相同。
    > 如果真正的拷贝构造函数只做了简单的拷贝，那么虚拟拷贝构造函数也做简单的拷贝。
    > 如果真正的拷贝构造函数做了全面的拷贝，那么虚拟拷贝构造函数也做全面的拷贝。
    > 如果真正的拷贝构造函数做一些奇特的事情，象引用计数或copy-on-write（参见条款 M29），那么虚拟构造函数也这么做。
    > 完全一致，太棒了。

    上述讨论的机制是如何将一个函数虚拟化，即：
    > 具有虚拟行为的非成员函数很简单。**你编写一个虚拟函数来完成工作，然后再写一个非虚拟函数，它什么也不做，只是调用这个虚拟函数**。
    > 为了避免这个句法花招引起函数调用开销，你当然可以内联这个非虚拟函数（参见 Effective C++ 条款 33）。

```
class A
{
public:
    A(int);
    A(A const &rhs);
    virtual ~A();
    virtual A* clone()
    {  
        return  new A (*this);
    }
};

class B:public A
{
public:
    B(int);
    B(B const &rhs);
    virtual ~B();
    virtual B* clone()
    {
        //return new B();    //调用构造函数；
        return new B(*this); //调用拷贝构造函数；
    }
};
```

38. 析构函数能不能虚函数？为什么？
    在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生。  
    如果不需要基类对派生类及对象进行操作,则不能定义虚函数,因为这样会增加内存开销.当类里面有定义虚函数的时候,编译器会给类添加一个虚函数表,里面来存放虚函数指针,这样就会增加类的存储空间.所以,只有当一个类被用来作为基类的时候,才把析构函数写成虚函数.  

39. 模板和实现可不可以不写在一个文件里面？为什么？
    分开写。只能写在一个一个的头文件中。原因：多文件处理变为一个文件其实是通过链接器来实现的，所以如果用源文件来处理模板实现，会导致链接失效，最主要的原因还是在编译，编译器会暂时不处理模板类只有在实例化对象时才去处理，但是这就需要实现的代码了，如果放在其他文件的话，就会无法形成相应的类。  

40. 什么是RAII资源管理？
    即资源获取就是初始化，利用对象生命周期来控制程序资源，简单来说就是通过局部对象来处理一些资源问题  

41. 如何检查内存泄露？如果不通过printf,debug等调试方式和编译器报错提示呢？
    使用GDB调试器  

42. Int(*f(int,void(*)()))(int,int)是什么意思？
    一个函数，参数为int和指向返回值为void的无参数的函数指针，返回值为一个指向返回值为int，参数为int和int的函数指针 

43. 初始化列表
    + 更高效：少了一次调用*默认构造函数*的过程。
    + 有些场合必须要用初始化列表：

        + 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
        + 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
        + 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是*直接调用拷贝构造函数初始化*。

44. 智能指针


45. Do{}while(0)的用法有哪些？

   + 可以将语句当做一个独立的域
   + 对于多语句可以正常的运行
   + 可以有效的消除goto语句，达到跳转语句的效果  

### STL

#### STL提供六大组件，彼此可以组合套用：

1. 容器（Containers）：各种数据结构，如：序列式容器vector、list、deque、关联式容器set、map、multiset、multimap。用来存放数据。从实现的角度来看，STL容器是一种class template。  

2. 算法（algorithms）：各种常用算法，如：sort、search、copy、erase。从实现的角度来看，STL算法是一种 function template。注意一个问题：任何的一个STL算法，都需要获得由一对迭代器所标示的区间，用来表示操作范围。这一对迭代器所标示的区间都是前闭后开区间，例如[first, last)  

3. 迭代器（iterators）：容器与算法之间的胶合剂，是所谓的“泛型指针”。共有五种类型，以及其他衍生变化。从实现的角度来看，迭代器是一种将 operator*、operator->、operator++、operator-- 等指针相关操作进行重载的class template。所有STL容器都有自己专属的迭代器，只有容器本身才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。  

4. 仿函数（functors）：行为类似函数，可作为算法的某种策略（policy）。从实现的角度来看，仿函数是一种重载了operator（）的class或class template。一般的函数指针也可视为狭义的仿函数。  

5. 配接器（adapters）：一种用来修饰容器、仿函数、迭代器接口的东西。例如：STL提供的queue 和 stack，虽然看似容器，但其实只能算是一种容器配接器，因为它们的底部完全借助deque，所有操作都由底层的deque供应。改变 functors接口者，称为function adapter；改变 container 接口者，称为container adapter；改变iterator接口者，称为iterator adapter。  

6. 配置器（allocators）：负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。  

+ 总结：这六大组件的交互关系：container（容器） 通过 allocator（配置器） 取得数据储存空间，algorithm（算法）通过 iterator（迭代器）存取 container（容器） 内容，functor（仿函数） 可以协助 algorithm（算法） 完成不同的策略变化，adapter（配接器） 可以修饰或套接 functor（仿函数）  

##### 序列式容器

+ vector-数组，元素不够时再重新分配内存，拷贝原来数组的元素到新分配的数组中.  
+ list-双向链表。  
+ deque-分配中央控制器map(并非map容器)，map记录着一系列的固定长度的数组的地址.记住这个map仅仅保存的是数组的地址,真正的数据在数组中存放着.deque先从map中央的位置(因为双向队列，前后都可以插入元素)找到一个数组地址，向该数组中放入数据，数组不够时继续在map中找空闲的数组来存数据。当map也不够时重新分配内存当作新的map,把原来map中的内容copy的新map中。所以使用deque的复杂度要大于vector，尽量使用vector。  
+ stack-基于deque。  
+ queue-基于deque。  
+ heap-完全二叉树，使用最大堆排序，以数组(vector)的形式存放。  
+ priority_queue-基于heap。  
+ slist-双向链表。  

##### 关联式容器

+ set,map,multiset,multimap-基于红黑树(RB-tree)，一种加上了额外平衡条件的二叉搜索树。

+ hash table-散列表。将待存数据的key经过映射函数变成一个数组(一般是vector)的索引，例如：数据的key%数组的大小＝数组的索引(一般文本通过算法也可以转换为数字)，然后将数据当作此索引的数组元素。有些数据的key经过算法的转换可能是同一个数组的索引值(碰撞问题，可以用线性探测，二次探测来解决)，STL是用开链的方法来解决的，每一个数组的元素维护一个list，他把相同索引值的数据存入一个list，这样当list比较短时执行删除，插入，搜索等算法比较快。  

+ hash_map,hash_set,hash_multiset,hash_multimap-基于hashtable。

 [STL六大组件] (http://blog.csdn.net/chenguolinblog/article/details/30336805)  

#### list和vector有什么区别？

+ vector拥有一段**连续**的内存空间，因此支持随机存取，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector。  
+ list  拥有一段**不连续**的内存空间，因此不支持随机存取，如果需要大量的插入和删除，而不关心随即存取，则应使用list。  

#### vector增长模式

+ size()函数返回的是已用空间大小，capacity()返回的是总空间大小，capacity()-size()则是剩余的可用空间大小。当size()和capacity()相等，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。reserve(n)预先分配一块较大的指定大小的内存空间，其中n为分配空间大小；resize()成员函数只改变元素的数目，不改变vector的容量。  
+ 在VS2010的编译器里面每次并不是增长固定的内存，可以看出是增长当前内存的一半。而且由于我们的程序没有调用reserve（n）函数预先分配一块内存，所以内存增长是编译器自动完成的。这个自动增长包括重新**分配内存空间、拷贝原空间、释放原空间**三个过程，具体策略为当添加元素时，如果vector空间大小不足，则会以原大小的**1.5倍**另外配置一块较大的新空间，然后将原空间内容拷贝过来，在新空间的内容末尾添加元素，并释放原空间。也就是说vector的空间动态增加大小，并不是在原空间之后的相邻地址增加新空间，因为vector的空间是线性连续分配的，不能保证原空间之后有可供配置的空间。这就解释了上述程序的运行结果。  
+ 但是，针对以上自动完成的内存增长过程，由于包括重新分配内存空间、拷贝原空间、释放原空间等步骤，这些过程会降低程序效率，因此可以使用reserve(n)预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。  

#### 各种容器之间的区别

+ vector：像数组一样，快速访问任何一个随机的元素，快速的再末尾插入元素，但是在序列中间插入以及删除要素比较慢，一开始分配的空间如果太小的话，重新分配，则拷贝的性能开销很大。  
+ deque：连续的内存区域，支持高效的首部插入和删除元素。  
+ list：非连续的内存区域，插入和删除效率高，随机访问支持不好。  
+ vector和数组之间的关系：数组的维度必须是常量表达式，初始化的时候必须给出。数组不允许拷贝和赋值，即不能将数组的内容拷贝到其他数组作为其初始值，但是vector可以。数组使用的过程容易产生数组越界，而相对于vector则可以使用较多的机制来控制，例如使用迭代器。  

1. 实现一个vector？是1.5还是2倍，各有什么优缺点？
    + 1.5倍优势：可以重用之前分配但是释放的内存;
    + 2倍劣势：每次申请的内存都不可以重用  

2. map底层用了什么？
    红黑树

3. 如果用map删除了一个元素，迭代器还能用吗？为什么？怎样做可以接着用？
    不能，自动指向下一个元素。list也是这样的。  
    应该iter = map.erase(iter);  

4. STL空间配置器如何处理内存的？能说一下它的大概实现方案吗？为什么是8bytes的倍数？
    分为两部分：大于128bytes用*malloc*直接申请，小于128bytes则使用*一个8bytes倍数的数组*来进行申请。  
    为8bytes的原因是为了提高效率，同时对于64位的机器而言，地址大小为8bytes  

