### 线程and进程

1. 信号的生命周期？  
    信号产生-》信号在进程中注册-》信号在进程中的注销-》执行信号处理函数  

2. 信号的产生方式？  
   + 当用户按某些终端键时产生信号  
   + 硬件异常产生信号【内存非法访问】  
   + 软件异常产生信号【某一个条件达到时】  
   + 调用kill函数产生信号【接受和发送的所有者必须相同，或者发送的进程所有者必须为超级用户
   + 运行kill命令产生信号  

3. 信号处理方式？  
   + 执行默认处理方式  
   + 忽略处理  
   + 执行用户自定义的函数  

4. linux内部提供了那些调试宏？
   + __FILE__：表示在哪个文件  
   + __LINE__：表示在当前多少行  
   + __FUNCTION__：表示在执行在哪个函数  

5. 死锁的原因？条件？如何预防？又如何避免？如何解除？

   1. 资源不能共享，只能由一个进程使用。
   2. 请求与保持（Hold andwait）：已经得到资源的进程可以再次申请新的资源。
   3. 不可剥夺（Nopre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。
   4. 循环等待：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源

   + 处理死锁的策略：  
     + 忽略该问题。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。
     + 检测死锁并且恢复。
     + 仔细地对资源进行动态分配，以避免死锁。
     + 通过破除死锁四个必要条件之一，来防止死锁产生。  

6. 解决hash冲突的方法？
    线性探测法；开链法；再哈希法；  

7. 进程与线程的区别？
    对于有线程系统：  
    * 进程是资源**分配**的独立单位
    * 线程是资源**调度**的独立单位

    对于无线程系统：
    * 进程是资源调度、分配的独立单位

##### 进程之间的通信方式以及优缺点

  * 管道（PIPE）
      * 有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信
          * 优点：可以实现任意关系的进程间的通信
          * 缺点：
              1. 长期存于系统中，使用不当容易出错
              2. 缓冲区有限
      * 无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）
          * 优点：简单方便
          * 缺点：
              1. 局限于单向通信 
              2. 只能创建在它的进程以及其有亲缘关系的进程之间
              3. 缓冲区有限
  * 信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问
      * 优点：可以同步进程
      * 缺点：信号量有限
  * 信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
  * 消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识
      * 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便
      * 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合
  * 共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问
      * 优点：无须复制，快捷，信息量大
      * 缺点：
          1. 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题
          2. 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信
  * 套接字（Socket）：可用于不同及其间的进程通信
      * 优点：
          1. 传输数据为字节级，传输数据可自定义，数据量小效率高
        2. 传输数据时间短，性能高
        3. 适合于客户端和服务器端之间信息实时交互
        4. 可以加密,数据安全性强
    * 缺点：需对传输的数据进行解析，转化成应用级的数据。

##### 线程之间的通信方式

  * 锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）
      * 互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。
      * 读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。
      * 自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持着是否已经释放锁。
      * 条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
  * 信号量机制(Semaphore)
      * 无名线程信号量
      * 命名线程信号量
  * 信号机制(Signal)：类似进程间的信号处理
  * 屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。

线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制  

> 进程之间的通信方式以及优缺点：[进程线程面试题总结](http://blog.csdn.net/wujiafei_njgcxy/article/details/77098977)

##### 进程之间私有和共享的资源

  * 私有：地址空间、堆、全局变量、栈、寄存器
  * 共享：代码段，公共数据，进程目录，进程 ID

##### 线程之间私有和共享的资源

  * 私有：线程栈，寄存器，程序寄存器
  * 共享：堆，地址空间，全局变量，静态变量

8. 什么是守护进程？如何查看守护进程？什么是僵尸进程？如何查看僵尸进程？
    + 守护进程：一个生命周期长，并且控制终端，然后周期性执行某种任务的进程  
    + 查看守护进程：ps a  
    + 僵尸进程：进程退出，但是占用资源没有被回收  
    + 查看僵尸进程：ps -ef|grep defunct  

9. 进程同步机制？
    进程间通信机制中唯一的异步通信机制  

10. 线程同步机制

    > 线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。  

    > 从大的方面讲，线程的同步可分*用户模式*的线程同步和*内核对象*的线程同步两大类。用户模式中线程的同步方法主要有*原子访问和临界区*等方法。其特点是同步速度特别快，适合于对线程运行速度有严格要求的场合。  

    > 内核对象的线程同步则主要由*事件、等待定时器、信号量以及信号灯*等内核对象构成。由于这种同步机制使用了内核对象，使用时必须将线程从用户模式切换到内核模式，而这种转换一般要耗费近千个CPU周期，因此同步速度较慢，但在适用性上却要远优于用户模式的线程同步方式。  

11. 什么是信号？
    一种比较复杂的通信方式，用于通知接收进程某个事件已经发生  

12. kill函数的每一个参数的作用？
    Pid>0：发给ID为pid的进程  
    Pid=0：发给进程组所有的进程  
    Pid=-1：发给所有的进程  
    Pid<-1：发给指定进程组的进程  

    这个 kill 命令不是真的“杀死”程序，而是给程序 发送信号。信号是操作系统与程序之间进行通信时所采用的几种方式中的一种。 在使用 Ctrl-c 和 Ctrl-z 的过程中我们已经看到信号的实际用法。当终端接受了其中一个按键组合后，它会给在前端运行 的程序发送一个信号。在使用 Ctrl-c 的情况下，会发送一个叫做 INT（Interrupt,中断）的信号；当使用 Ctrl-z 时，则发送一个叫做 TSTP（Terminal Stop,终端停止）的信号。程序，相应地，监听信号的到来，当程序 接到信号之后，则做出响应。一个程序能够监听和响应信号这件事允许一个程序做些事情， 比如，当程序接到一个终止信号时，它可以保存所做的工作。
    
> [“杀死”程序](https://www.cnblogs.com/whutao/p/10478946.html)
    
12. 虚拟内存实现有哪几种方式？有什么意义？
    三种：请求分页存储管理；请求分段存储管理；请求段页式存储管理 

13. 什么是类型安全？能举例吗？
    两个类型直接进行转换，必须是显式的，string和STL模板是类型安全的 

14. 确保线程安全的几种方式？
    + 原子操作
    + 同步与锁
    + 可重入
    + 阻止过度优化volatile

15. Pthread_cond_signal和pthread_cond_broadcast的区别
    + Pthread_cond_signal表示唤醒睡眠线程中的一个【单播，可能按照优先级或者先来后到的原则】  
    + Pthread_cond_boardcast表示唤醒所有睡眠线程【广播】  

16. 线程池的作用是什么？  
    处理线程多并发，用一个数组保存线程，然后一直放着，如果没用就用条件变量让它休眠，如果加入一个新的任务就唤醒其中一个去执行这个任务。  

17. 用户态和内核态的切换
    因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的资源，而且如果不对这些操作加以区分，很可能造成资源访问的冲突。  
    所以，为了减少有限资源的访问和使用冲突，Unix/Linux的设计哲学之一就是：对不同的操作赋予不同的执行等级，就是所谓特权的概念。简单说就是有多大能力做多大的事，与系统相关的一些特别关键的操作必须由最高特权的程序来完成。  
    Intel的X86架构的CPU提供了0到3四个特权级，数字越小，特权越高，**Linux操作系统中主要采用了0和3两个特权级，分别对应的就是内核态和用户态。**  
    运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。比如C函数库中的内存分配函数malloc()，它具体是使用sbrk()系统调用来分配内存，当malloc调用sbrk()的时候就涉及一次从用户态到内核态的切换，类似的函数还有printf()，调用的是wirte()系统调用来输出字符串，等等。  

    到底在什么情况下会发生从用户态到内核态的切换，一般存在以下三种情况：

    + 当然就是系统调用：原因如上的分析。
    + 异常事件： 当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。
    + 外围设备的中断：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。
