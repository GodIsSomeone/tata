# 一些零碎的知识点  
### new 和 malloc的区别
1. new需要调用构造函数，malloc只是申请一块内存。  
2. new不需要指定内存，malloc需要指定内存  
3. new出来的类型固定，malloc出来的是void*  
4. malloc出来的是在堆上内存，new出来的是自由存储区  
5. new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。  
6. 对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。  

### volatile关键字
+ Volatile关键词的第一个特性：易变性。所谓的易变性，在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。  
+ Volatile关键词的第二个特性：“不可优化”特性。volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。  
+ Volatile关键词的第三个特性：”顺序性”，能够保证Volatile变量间的顺序性，编译器不会进行乱序优化。  
+ C/C++ Volatile变量，与非Volatile变量之间的操作，是可能被编译器交换顺序的。C/C++ Volatile变量间的操作，是不会被编译器交换顺序的。哪怕将所有的变量全部都声明为volatile，哪怕杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力，针对这个多线程的应用，真正正确的做法，是构建一个happens-before语义。  
	

[C/C++ Volatile关键词深度剖析](http://hedengcheng.com/?p=725)

### static关键字

控制变量的存储方式和可见性。  
1. 修饰局部变量
一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。  

2. 修饰全局变量
对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。  

3. 修饰函数
用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。  

4. C++中的static
如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的对象所有。它们在存储空间中都只存在一个副本。可以通过类和对象去调用。  

### const的含义及实现机制

const名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。  
(1)const修饰基本数据类型  
+ const修饰一般常量及数组
基本数据类型，修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。   
+ const修饰指针变量*及引用变量&  
如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。  

(2)const应用到函数中  

+ 作为参数的const修饰符
调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。  
[注意]：参数const通常用于参数为指针或引用的情况; 

+ 作为函数返回值的const修饰符
声明了返回值后，const按照"修饰原则"进行修饰，起到相应的保护作用。  

(3)const在类中的用法  

+ 不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行  
类中的成员函数：A fun4()const; 其意义上是不能修改所在类的的任何变量。

(4)const修饰类对象，定义常量对象  
+ 常量对象只能调用常量函数，别的成员函数都不能调用。

http://www.cnblogs.com/wintergrass/archive/2011/04/15/2015020.html

### extern关键字

在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。  

注意extern声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，为啥要用extern？因为用extern会加速程序的编译过程，这样能节省时间。  

在C++中extern还有另外一种作用，用于指示C或者C＋＋函数的调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。  

### 宏定义和展开、内联函数区别

+ 内联函数是代码被插入到调用者代码处的函数。如同 #define 宏，内联函数通过避免被调用的开销来提高执行效率，尤其是它能够通过调用（“过程化集成”）被编译器优化。 宏定义不检查函数参数，返回值什么的，只是展开，相对来说，内联函数会检查参数类型，所以更安全。  
+ 内联函数和宏很类似，而区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。  
+ 宏是预编译器的输入，然后宏展开之后的结果会送去编译器做语法分析。宏与函数等处于不同的级别，操作不同的实体。宏操作的是 token, 可以进行 token的替换和连接等操作，在语法分析之前起作用。而函数是语言中的概念，会在语法树中创建对应的实体，内联只是函数的一个属性。  
+ 对于问题：有了函数要它们何用？答案是：一：函数并不能完全替代宏，有些宏可以在当前作用域生成一些变量，函数做不到。二：内联函数只是函数的一种，内联是给编译器的提示，告诉它最好把这个函数在被调用处展开，省掉一个函数调用的开销（压栈，跳转，返回）。  
+ 内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样。内联函数必须是和函数体申明在一起，才有效。  

[宏定义和内联函数区别](http://www.cnblogs.com/chengxuyuancc/archive/2013/04/04/2999844.html)

3.switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型   
1. auto会忽略顶层const，所以b的类型为int， 如果表达式的内容是解引用操作，则decltype将得到引用类型。   
5.无论是float还是double，在内存中的存储分为三部分，符号位，指数位，尾数位，位运算符对他们没有意义
6.引用和指针的区别。引用不为空，依附于别的值存在，指针可为空，引用不能重新定义，指针可以见异思迁。

### 多态   

#### 1.为什么会有多态的需求：怎么样才能解决，传入子类对象调用子类函数，传入基类对象调用基类函数呢？   
多态：就是根据实际的对象类型 决定 函数调用语句的具体调用目标。总结一句话就是，同样的调用语句有多种不同的表现形态。      
#### 2.C++编译器是如何实现上述需求的呢？   
基类与子类的同名函数，要想实现多态，基类同名函数必须声明为virtual函数。 要有继承，要有虚函数重写，父类指针(引用)指向子类对象。     
#### 3.静态联编和动态联编      
静态联编：静态联编是指联编工作在编译阶段完成的，这种联编过程是在程序运行之前完成的，又称为早期联编。要实现静态联编，在编译阶段就必须确定程序中的操作调用（如函数调用）与执行该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引用的类型。其优点是效率高，但灵活性差。    
动态联编：动态联编是指联编在程序运行时动态地进行，根据当时的情况来确定调用哪个同名函数，实际上是在运行时虚函数的实现。这种联编又称为晚期联编，或动态束定。动态联编对成员函数的选择是基于对象的类型，针对不同的对象类型将做出不同的编译结果。C++中一般情况下的联编是静态联编，但是当涉及到多态性和虚函数时应该使用动态联编。动态联编的优点是灵活性强，但效率低。 动态联编规定，只能通过指向基类的指针或基类对象的引用来调用虚函数，其格式为：指向基类的指针变量名->虚函数名（实参表）或基类对象的引用名.虚函数名（实参表）             

#### 4.重载，重写，重定义   
+ 函数重载：函数重载必须在同一个类中进行；子类无法重载父类函数，父类同名函数将被名称覆盖；重载是在编译器期间根据参数类型和个数决定函数调用(静态联编)。   
+ 函数重写：函数重写必须发生在父类与子类之间；父类与子类的函数原型完全一样；使用virtual声明之后能够产生多态(如果不写virtual关键字，称为重定义)；  
+ 多态是在运行期间根据具体对象的类型来决定函数调用    
#### 5.编译器在什么地方动了手脚，从而支持了多态？     
真正确定绑定关系的地方，就是创建对象的时候！！这时候C++编译器会偷偷的给对象添加一个vptr指针。  
　只要我们在类中定义了virtual函数，那么我们在定义对象的时候，C++编译器会在对象中存储一个vptr指针，类中创建的虚函数的地址会存放在一个虚函数表中，vptr指针就是指向这个表的首地址。     
在发生多态的地方，也就上面的，编译器根本不会去区分，传进来的是子类对象还是父类对象。而是关心print()是否为虚函数，如果是虚函数，就根据不同对象的vptr指针找属于自己的函数。而且父类对象和子类对象都会有vptr指针，传入对象不同，编译器会根据vptr指针，到属于自己虚函数表中找自己的函数。即：vptr--->虚函数表------>函数的入口地址，从而实现了迟绑定(在运行的时候，才会去判断)。     
如果不是虚函数，那么这种绑定关系在编译的时候就已经确定的，也就是*静态联编！*     
+ 说明1：通过虚函数表指针VPTR调用重写函数是在程序运行时进行的，因此需要通过寻址操作才能确定真正应该调用的函数。而普通成员函数是在编译时就确定了调用的函数。在效率上，虚函数的效率要低很多。  
+ 说明2：出于效率考虑，没有必要将所有成员函数都声明为虚函数     
+ 说明3 ：C++编译器，执行play函数，不需要区分是子类对象还是父类对象     
  
#### 6.多态的实现原理     
+ 说明1：通过虚函数表指针VPTR调用重写函数是在程序运行时进行的，因此需要通过寻址操作才能确定真正应该调用的函数。而普通成员函数是在编译时就确定了调用的函数。在效率上，虚函数的效率要低很多。     
+ 说明2：出于效率考虑，没有必要将所有成员函数都声明为虚函数        
+ 说明3 ：C++编译器，执行play函数，不需要区分是子类对象还是父类对象          
  
#### 7.构造函数中能调用虚函数，实现多态么？     
不会发生多态。当定义一个子类对象的时候比较麻烦，因为构造子类对象的时候会首先调用父类的构造函数然后再调用子类的构造函数。当调用父类的构造函数的时候，此时会创建Vptr指针（也可以认为Vptr指针是属于父类的成员，所以在子类中重写虚函数的时候virtual关键字可以省略，因为编译器会识别父类有虚函数，然后就会生成Vptr指针变量），该指针会指向父类的虚函数表；然后再调用子类的构造函数，此时Vptr又被赋值指向子类的虚函数表。（执行父类的构造函数的时候Vptr指针指向的是父类的虚函数表，所以只能执行父类的虚函数）         

### 内存
#### 内存的种类
在c++中，共有五种内存。*栈、堆、自由存储区、全局/静态存储区、常量存储区*。    
栈中存储一些局部变量，在作用区域结束后，被程序释放掉。       
堆中存储一些new出来的变量，自己new，自己delete。    
自由存储区，malloc出来的。自己free。     
全局/静态存储区，常量存储区， 顾名思义    
#### 堆内存和栈内存的区别    
1. 栈内存由系统分配，系统负责管理，栈内存由开发者进行管理，容易发生内存泄漏   
2. 空间大小不同，堆内存一般可以达到4G（32系统），栈内存一般较小（可以修改）    
3. 碎片问题，堆内存频繁的new/delete会影响程序的效率，栈内存则不会，清空操作的时候，后进先出，已经清理完毕了。    
4. 生长方向，堆内存是向着地址逐渐增大的方向，栈内存是向着地址逐渐变小的方向。  
5. 分配效率，栈内存由计算机系统底层进行指令支持，效率要高一些；堆内存有c++函数库进行支持，按照大小进行空间搜索进行分配，如果没有足够大的空间，则向系统申请空间。    
#### 常见内存错误    
1.内存没有申请成功，却使用了他      
2.内存申请成功，却没有初始化。         
3.内存越界。     
4.忘记释放内存，或者释放内存后继续使用。         

### 字节对齐   
现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际情况上，在访问特定类型变量的时候经常在特定的内存地址访问，这就是需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。   
平台的原因：不是所有的平台都是任意的访问数据的，某些硬件平台只能在某些地址处取某些数据 ，否则抛异常。     
性能的原因：数据结构应该尽可能地再自然边界上对齐，原因在于为了访问未对齐的内存，处理器需要做两次访问内存，而对齐的内存访问只需要一次访问。    
指针、多态（虚函数表、内存 layout等）、作用域、内存的管理          

### STL

STL提供六大组件，彼此可以组合套用：

1. 容器（Containers）：各种数据结构，如：序列式容器vector、list、deque、关联式容器set、map、multiset、multimap。用来存放数据。从实现的角度来看，STL容器是一种class template。  

2. 算法（algorithms）：各种常用算法，如：sort、search、copy、erase。从实现的角度来看，STL算法是一种 function template。注意一个问题：任何的一个STL算法，都需要获得由一对迭代器所标示的区间，用来表示操作范围。这一对迭代器所标示的区间都是前闭后开区间，例如[first, last)  

3. 迭代器（iterators）：容器与算法之间的胶合剂，是所谓的“泛型指针”。共有五种类型，以及其他衍生变化。从实现的角度来看，迭代器是一种将 operator*、operator->、operator++、operator- - 等指针相关操作进行重载的class template。所有STL容器都有自己专属的迭代器，只有容器本身才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。  

4. 仿函数（functors）：行为类似函数，可作为算法的某种策略（policy）。从实现的角度来看，仿函数是一种重载了operator（）的class或class template。一般的函数指针也可视为狭义的仿函数。  

5. 配接器（adapters）：一种用来修饰容器、仿函数、迭代器接口的东西。例如：STL提供的queue 和 stack，虽然看似容器，但其实只能算是一种容器配接器，因为它们的底部完全借助deque，所有操作都由底层的deque供应。改变 functors接口者，称为function adapter；改变 container 接口者，称为container adapter；改变iterator接口者，称为iterator adapter。  

6. 配置器（allocators）：负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。  

+ 总结：这六大组件的交互关系：container（容器） 通过 allocator（配置器） 取得数据储存空间，algorithm（算法）通过 iterator（迭代器）存取 container（容器） 内容，functor（仿函数） 可以协助 algorithm（算法） 完成不同的策略变化，adapter（配接器） 可以修饰或套接 functor（仿函数）  

序列式容器：  
vector-数组，元素不够时再重新分配内存，拷贝原来数组的元素到新分配的数组中。  
list-单链表。  
deque-分配中央控制器map(并非map容器)，map记录着一系列的固定长度的数组的地址.记住这个map仅仅保存的是数组的地址,真正的数据在数组中存放着.deque先从map中央的位置(因为双向队列，前后都可以插入元素)找到一个数组地址，向该数组中放入数据，数组不够时继续在map中找空闲的数组来存数据。当map也不够时重新分配内存当作新的map,把原来map中的内容copy的新map中。所以使用deque的复杂度要大于vector，尽量使用vector。  
stack-基于deque。  
queue-基于deque。  
heap-完全二叉树，使用最大堆排序，以数组(vector)的形式存放。  
priority_queue-基于heap。  
slist-双向链表。  

关联式容器：  
set,map,multiset,multimap-基于红黑树(RB-tree)，一种加上了额外平衡条件的二叉搜索树。   

hash table-散列表。将待存数据的key经过映射函数变成一个数组(一般是vector)的索引，例如：数据的key%数组的大小＝数组的索引(一般文本通过算法也可以转换为数字)，然后将数据当作此索引的数组元素。有些数据的key经过算法的转换可能是同一个数组的索引值(碰撞问题，可以用线性探测，二次探测来解决)，STL是用开链的方法来解决的，每一个数组的元素维护一个list，他把相同索引值的数据存入一个list，这样当list比较短时执行删除，插入，搜索等算法比较快。  

hash_map,hash_set,hash_multiset,hash_multimap-基于hashtable。

 [STL六大组件] (http://blog.csdn.net/chenguolinblog/article/details/30336805)  

#### list和vector有什么区别？
vector拥有一段连续的内存空间，因此支持随机存取，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector。  
list拥有一段不连续的内存空间，因此不支持随机存取，如果需要大量的插入和删除，而不关心随即存取，则应使用list。  

#### vector增长模式        
+ size()函数返回的是已用空间大小，capacity()返回的是总空间大小，capacity()-size()则是剩余的可用空间大小。当size()和capacity()相等，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。reserve(n)预先分配一块较大的指定大小的内存空间，其中n为分配空间大小；resize()成员函数只改变元素的数目，不改变vector的容量。     
+ 在VS2010的编译器里面每次并不是增长固定的内存，可以看出是增长当前内存的一半。而且由于我们的程序没有调用reserve（n）函数预先分配一块内存，所以内存增长是编译器自动完成的。这个自动增长包括重新分配内存空间、拷贝原空间、释放原空间三个过程，具体策略为当添加元素时，如果vector空间大小不足，则会以原大小的1.5倍另外配置一块较大的新空间，然后将原空间内容拷贝过来，在新空间的内容末尾添加元素，并释放原空间。也就是说vector的空间动态增加大小，并不是在原空间之后的相邻地址增加新空间，因为vector的空间是线性连续分配的，不能保证原空间之后有可供配置的空间。这就解释了上述程序的运行结果。       
+ 但是，针对以上自动完成的内存增长过程，由于包括重新分配内存空间、拷贝原空间、释放原空间等步骤，这些过程会降低程序效率，因此可以使用reserve(n)预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。    

#### 各种容器之间的区别    
+ vector：像数组一样，快速访问任何一个随机的元素，快速的再末尾插入元素，但是在序列中间插入以及删除要素比较慢，一开始分配的空间如果太小的话，重新分配，则拷贝的性能开销很大。   
+ deque：连续的内存区域，支持高效的首部插入和删除元素。    
+ list：非连续的内存区域，插入和删除效率高，随机访问支持不好。     
+ vector和数组之间的关系：数组的维度必须是常量表达式，初始化的时候必须给出。数组不允许拷贝和赋值，即不能将数组的内容拷贝到其他数组作为其初始值，但是vector可以。数组使用的过程容易产生数组越界，而相对于vector则可以使用较多的机制来控制，例如使用迭代器。   
  

## 操作系统：

### linux的内存管理机制，内存寻址方式，什么叫虚拟内存，内存调页算法，任务调度算法、

1. Linux虚拟内存的实现需要6种机制的支持：地址映射机制、内存分配回收机制、缓存和刷新机制、请求页机制、交换机制和内存共享机制  
2. 内存管理程序通过映射机制把用户程序的逻辑地址映射到物理地址。当用户程序运行时，如果发现程序中要用的虚地址没有对应的物理内存，就发出了请求页要求。如果有空闲的内存可供分配，就请求分配内存(于是用到了内存的分配和回收)，并把正在使用的物理页记录在缓存中(使用了缓存机制)。如果没有足够的内存可供分配，那么就调用交换机制；腾出一部分内存。另外，在地址映射中要通过TLB(翻译后援存储器)来寻找物理页；交换机制中也要用到交换缓存，并且把物理页内容交换到交换文件中，也要修改页表来映射文件地址。

### 死锁必要条件及避免算法

1. 资源不能共享，只能由一个进程使用。
2. 请求与保持（Hold andwait）：已经得到资源的进程可以再次申请新的资源。
3. 不可剥夺（Nopre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。
4. 循环等待：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源

+ 处理死锁的策略：
      
  + 忽略该问题。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。
  + 检测死锁并且恢复。
  + 仔细地对资源进行动态分配，以避免死锁。
  + 通过破除死锁四个必要条件之一，来防止死锁产生。  

### 动态链接和静态链接的区别、

动态链接是只建立一个引用的接口，而真正的代码和数据存放在另外的可执行模块中，在运行时再装入；而静态链接是把所有的代码和数据都复制到本模块中，运行时就不再需要库了。   


### 网络：TCP和UDP区别
*TCP是一种面向连接的、可靠的、字节流服务*
1. 面向链接：TCP面向链接，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须通过三次握手先建立一个TCP连接。在一个TCP中仅有两方彼此通信，多播和广播不能用于TCP。UDP是不可靠的传输，传输前不需要建立链接，可以应用多播和广播实现一对多的通信。
2. 可靠性：TCP提供端到端的流量控制，对收到的数据进行确认，采用超时重发，对失序的数据进行重新排序等机制保证数据通信的可靠性。而UDP是一种不可靠的服务，接收方可能不能收到发送方的数据报。
3. TCP是一种流模式的协议，UDP是一种数据报模式的协议。进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。TCP应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系。TCP会有粘包和半包的现象。
4. 效率上：速度上，一般TCP速度慢，传输过程中需要对数据进行确认，超时重发，还要对数据进行排序。UDP没有这些机制所以速度快。数据比例，TCP头至少20个字节，UDP头8个字节，相对效率高。组装效率上：TCP头至少20个字节，UDP头8个字节，系统组装上TCP相对慢。
5. 用途上：用于TCP可靠性，http，ftp使用。而由于UDP速度快，视频，在线游戏多用UDP，保证实时性

对于第三点的理解。TCP可能发送100个“包”，而接收到50个“包”，不是丢“包”了，而是每次接受的“包”都比发送的多，其实TCP并没有包的概念。例如，每次发10个字节，可能读得时候一次读了20个字节。TCP是一种流模式的协议，在接收到的缓存中按照发送的包得顺序自动按照顺序拼接好，因为数据基本来自同一个主机，而且是按照顺序发送过来的，TCP的缓存中存放的就是，连续的数据。感觉好像是多封装了一步比UDP。而UDP因为可能两个不同的主机，给同一个主机发送，（一个端口可能收到多个应用程序的数据），或者按照TCP那样合并数据，必然会造成数据错误。我觉得关键的原因还是，TCP是面向连接，而UDP是无连接的，这就导致，TCP接收的数据为一个主机发来且有序无误的，而UDP可能是多个主机发来的无序，可能错误的。  




# HASH的设计
# 几个常用工具的使用，gdb,gcc,git
# 多线程相关，多线程主要问高并发、通信，然后还有锁相关的东西   
# 工具：
编译工具GCC，调试工具GDB，性能优化工具Perf,内存泄露检查工具Valgrind,makefile编写
其他工具: netstat,ps,top,df,fdisk,lsof，ifconfig,uname,kill，tcpdump，ipcs，grep

### 写string类的构造，析构，拷贝函数

```
class String
{
  public:
          String(const char *str=NULL); //构造函数
          String(const String &other); //拷贝构造函数
          ~String(void); //析构函数
          String& operator=(const String &other); //等号操作符重载
          ShowString();

  private:
          char *m_data; //指针
};

String::~String()
{
    delete [] m_data; //析构函数，释放地址空间
}
String::String(const char *str)
{
    if (str==NULL)//当初始化串不存在的时候，为m_data申请一个空间存放'\0'；
    {
        m_data=new char[1];
        *m_data='\0';
    }
    else//当初始化串存在的时候，为m_data申请同样大小的空间存放该串；
    {
        int length=strlen(str);
        m_data=new char[length+1];
        strcpy(m_data,str);
    }
}

String::String(const String &other)//拷贝构造函数，功能与构造函数类似。
{
    int length=strlen(other.m_data);
    m_data=new [length+1];
    strcpy(m_data,other.m_data);
}
String& String::operator =(const String &other) 
{
    if (this==&other)//当地址相同时，直接返回；
        return *this; 

    delete [] m_data;//当地址不相同时，删除原来申请的空间，重新开始构造；
    int length=sizeof(other.m_data);
    m_data=new [length+1];
    strcpy(m_data,other.m_data);
    return *this; 
}

String::ShowString()//由于m_data是私有成员，对象只能通过public成员函数来访问；
{
      cout<<this->m_data<<endl;
}

main()
{
String AD;
char * p="ABCDE";
String B(p);
AD.ShowString();
AD=B;
AD.ShowString();

}
```

### 库函数实现：
malloc,strcpy,strcmp的实现，常用库函数实现，哪些库函数属于高危函数

```
char *mystrcat(char *dest,const char *src)
{
    char* temp = dest;
    while(*dest != '\0')
    {
        dest++;
    }

    while((*dest++ = *src++) != '\0');

    return temp;
}
char *mystrncat(char *dest,const char *src,size_t n)
{
    
    char* temp = dest;
    while(*dest != '\0')
    {
        dest++;
    }

    while(n-->0 && (*dest++ = *src++) != '\0');

    return temp;
}



void* mymemset(void *s, int c, size_t n )
{
    unsigned char uc = c;
    unsigned char *su = (unsigned char*)s;
    while(n-->0)
    {
        *su = uc;
        su++;
    }
}

int mystrlen(const char* str)
{
    return *str?(mystrlen(++str)+1):0;
    /*
    const char* eos = str;
    while(*eos++);
    return (eos-str-1);
    */
}

void* mymemcpy(void* dst, const void* src,size_t size)
{
    
    if(src==NULL || dst==NULL) return NULL;
    void* ret = dst;
    while(size--)
    {
        *(char*)dst = *(char*)src;
        dst = (char*)dst + 1;
        src = (char*)src + 1;
    }
    return ret;
}

void* mymemmove(void* dst, const void* src,size_t size)
{
    if(src==NULL || dst==NULL) return NULL;
    char* psrc;
    char* pdst;
    //存在覆盖，自后向前进行拷贝
    if((src<dst) && (char*)src+size > (char*)dst)
    {
        psrc = (char*)src + size-1;
        pdst = (char*)dst + size-1;
        while(size--)
            *pdst-- = *psrc--;
    }
    else
    {
        psrc = (char*)src;
        pdst = (char*)dst;
        while(size--)
        {
            *pdst++ = *psrc++;
        }
    }
}

int mymemcmp(const void * ptr1, const void * ptr2, size_t num)
{
    if(ptr1==NULL || ptr2==NULL || num<0) return 0;

    char* pch1 = (char*)ptr1;
    char* pch2 = (char*)ptr2;

    while(num-- && *pch1++ == *pch2++);
    return (pch1-pch2)<<8;
}

int mystrcmp ( const char * str1, const char * str2 )
{
    if(str1==NULL || str2 ==NULL) return 0;

    while(*str1 == *str2)
    {
        str1++;
        str2++;
    }

    return (*str1-*str2);
}

int mystrncmp( const char * str1, const char * str2, size_t num )
{

    if(str1==NULL || str2 ==NULL) return 0;

    while(num-- && *str1 == *str2)
    {
        str1++;
        str2++;
    }

    return (*str1-*str2);
}

```
