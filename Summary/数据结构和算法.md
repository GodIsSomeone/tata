### 数据结构

#### 数组

1. 数组和链表的区别
    C++语言中可以用数组处理一组数据类型相同的数据，但不允许动态定义数组的大小，即在使用数组之前必须确定数组的大小。而在实际应用中，用户使用数组之前无法确定数组的大小，只能够将数组定义成足够大小，这样数组的空间可能不被使用，从而造成内存空间的浪费。链表是一种常见的数据组织形式，他采用动态分配内存的形式实现。需要时可以用new分配内存空间，不需要时用delete将已分配的空间释放，不会造成内存空间的浪费。  

    从逻辑结构上来看，数组必须实现定于固定的长度，不能适应数据动态增减的情况，即数组的大小一旦定义就不能改变。当数据增加是，可能超过原先定义的元素的个数；当数据减少时，造成内存浪费；链表动态进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。  

    从内存存储的角度看；数组从栈中分配空间（用new则在堆上创建），对程序员方便快速，但是自由度小；链表从堆中分配空间，自由度大但是申请管理比较麻烦。  

    从访问方式类看，数组在内存中是连续的存储，因此可以利用下标索引进行访问；链表是链式存储结构，在访问元素时候只能够通过线性方式由前到后顺序的访问，所以访问效率比数组要低。  

2. 第K大的数字

    方法1：快排的变种。只确定中间值index，不对左右两边进行排序。时间复杂度O(n logk)。

    ```
    int quickGet(int arr[], int begin, int end)
    {
        int ret = 0;
        if(begin<end)
        {
            int flag = begin;
            int right = end;
            int cur = arr[begin];
            while (flag < right)
            {
                while(right > flag && arr[right] >= cur)
                    right--;
                if(right>flag)
                {
                    arr[flag] = arr[right];
                    flag++;
                }
                while(flag < end && arr[flag] < cur)
                    flag++;
                if(right > flag)
                {
                    arr[right] = arr[flag];
                    right--;
                }
            }
            arr[flag] = cur;
            ret = flag;
        }
        return ret;
    }

    void maxK(int arr[], int size, int k)
    {
        checkParam(arr, size);
        if (k == 0)
            return ;
        int arrK[k];
        int index = quickGet(arr, 0, size - 1);
        while(index!=k)
        {
            if(index<k)
                index = quickGet(arr,index+1,size-1);
            else
                index = quickGet(arr,0,index-1);
        }

        int j =0;
        for(int i=0;i<k;i++)
        {
            if(arr[i]<arr[index])
            {
                arrK[j] = arr[i];
                j++;
            }
        }
        return ;
    }
    ```

    方法2：冒泡法,时间复杂度O(n*K)

    ```
    void maxKbyBubble(int arr[], int size, int k)
    {
        int arrK[k];   //定义数组

        for(int i=0;i<k;i++)
        {
            for(int j=0;j<size-1-i; j++)
            {
                if(arr[j]<arr[j+1])
                {
                    int temp = arr[j + 1];
                    arr[j + 1] = arr[j];
                    arr[j] = temp;
                }
            }

            arrK[i] = arr[size-1-i]; //末尾数字赋值
        }

        printArray(arrK, k);
        return;
    }
    ```

    方法三：堆排序的变种

    ```
    /*
    堆排序：大顶堆（升序，小到大），小顶堆（降序，大到小）。  
    大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]  
    小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]  
    然后对左边的数据，和右边的数据进行处理。  
    时间复杂度：平均 O(NlogK,2为底)  
    空间复杂度：O(1)  
    不稳定  
    */

    void create_heap(int array[], int begin, int end)
    {
        int son = begin * 2 + 1;
        int dad = begin;
        while (son <= end)
        {
            if (son + 1 <= end && array[son] < array[son + 1])
            {
                son++;
            }

            if (array[dad] > array[son])
                return;
            else
            {
                std::swap(array[dad], array[son]);
                dad = son;
                son = dad * 2 + 1;
            }
        }
    }

    void heap_sort(int array[], int length, int k)
    {
        //参数判断
        //1.构建大顶堆
        for (int i = k / 2 - 1; i >= 0; i--)
        {
            //从最后一个非叶子结点从下至上，从右至左调整结构
            create_heap(array, i, k - 1);
        }

        //2.调整堆结构+交换堆顶元素与末尾元素
        for (int i = length - 1; i > 0; i--)
        {
            if (array[i] < array[0])
            {
                std::swap(array[0], array[i]); //将堆顶元素与末尾元素进行交换
                create_heap(array, 0, i - 1);  //重新对堆进行调整
            }
        }

        printArray(array, k);
    }
    ```

3. 丑数

    范围内的丑数集合

    ```
    int GetUglyNumber_Solution(int index) {
        if (index < 7) return index;
        vector<int> vRet(index);
        vRet[0] = 1;//最小丑数
        int t1 = 0, t2 = 0, t3 = 0;
        for (int i = 1; i < index; i++)
        {
            vRet[i] = min(vRet[t1] * 2, min(vRet[t2] * 3, vRet[t3] * 5));
            if (vRet[i] == vRet[t1] * 2) t1++;
            if (vRet[i] == vRet[t2] * 3) t2++;
            if (vRet[i] == vRet[t3] * 5) t3++;
        }
        return vRet[index - 1];
    }
    ```

#### 链表

1. 单链表翻转

    从头到尾遍历原链表，每遍历一个结点，将其摘下放在新链表的最前端。注意链表为空和只有一个结点的情况。时间复杂度为O（n）.  

    ```
    ListNode* reverseList(ListNode* pHead)
    {
        /*check the param*/
        if(nullptr == pHead || nullptr == phead->next)
            return pHead;

        ListNode* pReverseHead = nullptr;
        ListNode* pCur = pHead;
        while(pCur)
        {
            ListNode* pTemp = pCur;
            pCur = pCur->next;
            pTemp->next = pReverseHead;
            pReverseHead = pTemp;
        }
        return pReverseHead;
    }
    ```

2. 查找单链表中倒数第K个结点（K>0）

    最普通的方法是：先统计单链表中结点的个数，然后再找到第（n-k）个结点。注意链表为空，k为0，k为1，k大于链表中节点个数时的情况。时间复杂度为O（n）。代码略。  
    **链表中双指针的一快一慢的使用频率特别高。**
    方法二：主要思路就是使用两个指针，先让前面的指针走到正向第k个结点，这样前后两个指针的距离差是k-1，之后前后两个指针一起向前走，前面的指针走到最后一个结点时，后面指针所指结点就是倒数第k个结点。  

    ```
    ListNode* getKthNode(ListNode* pHead, int k)
    {
        /*check the param*/
        if(nullptr == pHead || k<=0)
            return nullptr;

        ListNode* pAlphaHead = pHead; /*先走*/
        ListNode* pBetaHead = pHead;  /*后走*/

        /*Alpha先走到第K个结点*/
        while(k>1 && pAlphaHead != nullptr)
        {
            pAlphaHead = pAlphaHead->next;
            k--;
        }

        if(k>1 || pAlphaHead != nullptr)
            return nullptr;

        /*pAlphaHead走到底，pBetaHead开始走*/
        while(pAlphaHead->next != nullptr)
        {
            pBetaHead = pBetaHead->next;
            pAlphaHead = pAlphaHead->next;
        }

        return pBetaHead;
    }
    ```

3. 查找单链表的中间结点

    同上一题所做的分析，两个指针同时向前走，前面的指针每次走两步，后面的指针每次走一步，前面的指针走到最后一个结点时，后面的指针所指结点就是中间结点，即第（n/2+1）个结点。注意链表为空，链表结点个数为1和2的情况。时间复杂度O（n）  

    ```
    ListNode* getMiddleList(ListNode* pHead)
    {
        /*check the param*/
        if(nullptr == pHead || nullptr == phead->next) 
            return pHead;

        ListNode* pAlphaHead = pHead; /*先走*/
        ListNode* pBetaHead  = pHead; /*后走*/

        /*Alpha先走到底，不过一次走两步，Beta一次走一步，这样，Alpha走到结尾的时候，Beta刚好在中间位置*/
        while(pAlphaHead->next != nullptr)
        {
            pAlphaHead = pAlphaHead->next->next;
            pBetaHead = pAlphaHead->next;
        }

        return pBetaHead;
    }
    ```

4. 倒序输出链表

   对于这种颠倒顺序的问题，我们应该就会想到栈，后进先出。所以，这一题要么自己使用栈，要么让系统使用栈，也就是递归。注意链表为空的情况。时间复杂度为O（n）  

    ```
    // 从尾到头打印链表，使用栈
    void RPrintList(ListNode * pHead)
    {
        std::stack<ListNode *> s;
        ListNode * pNode = pHead;
        while(pNode != NULL)
        {
            s.push(pNode);
            pNode = pNode->m_pNext;
        }
        while(!s.empty())
        {
            pNode = s.top();
            printf("%d\t", pNode->m_nKey);
            s.pop();
        }
    }
    ```

    使用递归  

    ```
    // 从尾到头打印链表，使用递归
    void RPrintList(ListNode * pHead)
    {
        if(pHead == NULL)
        {
            return;
        }
        else
        {
            RPrintList(pHead->m_pNext);
            printf("%d\t", pHead->m_nKey);
        }
    }
    ```

5. 合并有序链表

    这个类似归并排序。尤其注意两个链表都为空，和其中一个为空时的情况。只需要O（1）的空间。时间复杂度为O(max(len1, len2))  

    ```
    // 合并两个有序链表
    ListNode * MergeSortedList(ListNode * pHead1, ListNode * pHead2)
    {
        if(pHead1 == NULL)
            return pHead2;
        if(pHead2 == NULL)
            return pHead1;
        ListNode * pHeadMerged = NULL;
        if(pHead1->m_nKey < pHead2->m_nKey)
        {
            pHeadMerged = pHead1;
            pHeadMerged->m_pNext = NULL;
            pHead1 = pHead1->m_pNext;
        }
        else
        {
            pHeadMerged = pHead2;
            pHeadMerged->m_pNext = NULL;
            pHead2 = pHead2->m_pNext;
        }
        ListNode * pTemp = pHeadMerged;
        while(pHead1 != NULL && pHead2 != NULL)
        {
            if(pHead1->m_nKey < pHead2->m_nKey)
            {
                pTemp->m_pNext = pHead1;
                pHead1 = pHead1->m_pNext;
                pTemp = pTemp->m_pNext;
                pTemp->m_pNext = NULL;
            }
            else
            {
                pTemp->m_pNext = pHead2;
                pHead2 = pHead2->m_pNext;
                pTemp = pTemp->m_pNext;
                pTemp->m_pNext = NULL;
            }
        }
        if(pHead1 != NULL)
            pTemp->m_pNext = pHead1;
        else if(pHead2 != NULL)
            pTemp->m_pNext = pHead2;
        return pHeadMerged;
    }
    ```

    递归解法

    ```
    ListNode * MergeSortedList(ListNode * pHead1, ListNode * pHead2)
    {
        if(pHead1 == NULL)
            return pHead2;
        if(pHead2 == NULL)
            return pHead1;
        ListNode * pHeadMerged = NULL;
        if(pHead1->m_nKey < pHead2->m_nKey)
        {
            pHeadMerged = pHead1;
            pHeadMerged->m_pNext = MergeSortedList(pHead1->m_pNext, pHead2);
        }
        else
        {
            pHeadMerged = pHead2;
            pHeadMerged->m_pNext = MergeSortedList(pHead1, pHead2->m_pNext);
        }
        return pHeadMerged;
    }
    ```

6. 判断链表中是否有环

    这里也是用到两个指针。如果一个链表中有环，也就是说用一个指针去遍历，是永远走不到头的。因此，我们可以用两个指针去遍历，一个指针一次走两步，一个指针一次走一步，如果有环，两个指针肯定会在环中相遇。时间复杂度为O（n）。  

    ```
    bool HasCircle(ListNode * pHead)
    {
        ListNode * pFast = pHead; // 快指针每次前进两步
        ListNode * pSlow = pHead; // 慢指针每次前进一步
        while(pFast != NULL && pFast->m_pNext != NULL)
        {
            pFast = pFast->m_pNext->m_pNext;
            pSlow = pSlow->m_pNext;
            if(pSlow == pFast) // 相遇，存在环
                return true;
        }
        return false;
    }
    ```

7. 判断两个单链表是否相交

    如果两个链表相交于某一节点，那么在这个相交节点之后的所有节点都是两个链表所共有的。也就是说，如果两个链表相交，那么最后一个节点肯定是共有的。先遍历第一个链表，记住最后一个节点，然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则不相交。时间复杂度为O(len1+len2)，因为只需要一个额外指针保存最后一个节点地址，空间复杂度为O(1)。  

    ```
    bool IsIntersected(ListNode * pHead1, ListNode * pHead2)
    {
        if(pHead1 == NULL || pHead2 == NULL)
                return false;

        ListNode * pTail1 = pHead1;
        while(pTail1->m_pNext != NULL)
            pTail1 = pTail1->m_pNext;

        ListNode * pTail2 = pHead2;
        while(pTail2->m_pNext != NULL)
            pTail2 = pTail2->m_pNext;
        return pTail1 == pTail2;
    }
    ```

8. 求两个单链表相交的第一个结点

    对第一个链表遍历，计算长度len1，同时保存最后一个节点的地址。  
    对第二个链表遍历，计算长度len2，同时检查最后一个节点是否和第一个链表的最后一个节点相同，若不相同，不相交，结束。  
    两个链表均从头节点开始，假设len1大于len2，那么将第一个链表先遍历len1-len2个节点，此时两个链表当前节点到第一个相交节点的距离就相等了，然后一起向后遍历，知道两个节点的地址相同。  
    时间复杂度，O(len1+len2)。  

    ```
    ListNode* GetFirstCommonNode(ListNode * pHead1, ListNode * pHead2)
    {
        if(pHead1 == NULL || pHead2 == NULL)
            return NULL;

        int len1 = 1;
        ListNode * pTail1 = pHead1;
        while(pTail1->m_pNext != NULL)
        {
            pTail1 = pTail1->m_pNext;
            len1++;
        }

        int len2 = 1;
        ListNode * pTail2 = pHead2;
        while(pTail2->m_pNext != NULL)
        {
            pTail2 = pTail2->m_pNext;
            len2++;
        }

        if(pTail1 != pTail2) // 不相交直接返回NULL
            return NULL;

        ListNode * pNode1 = pHead1;
        ListNode * pNode2 = pHead2;

        // 先对齐两个链表的当前结点，使之到尾节点的距离相等
        if(len1 > len2)
        {
            int k = len1 - len2;
            while(k--)
                pNode1 = pNode1->m_pNext;
        }
        else
        {
            int k = len2 - len1;
            while(k--)
                pNode2 = pNode2->m_pNext;
        }
        while(pNode1 != pNode2)
        {
            pNode1 = pNode1->m_pNext;
            pNode2 = pNode2->m_pNext;
        }
        return pNode1;
    }
    ```

9.  已知一个单链表中存在环，求进入环中的第一个结点

    首先判断是否存在环，若不存在结束。  
    在环中的一个节点处断开，这样就形成了两个相交的单链表，求进入环中的第一个节点也就转换成了求两个单链表相交的第一个节点。  

    ```
    ListNode* GetFirstNodeInCircle(ListNode * pHead)
    {
        if(pHead == NULL || pHead->m_pNext == NULL)
            return NULL;

        ListNode * pFast = pHead;
        ListNode * pSlow = pHead;
        while(pFast != NULL && pFast->m_pNext != NULL)
        {
            pSlow = pSlow->m_pNext;
            pFast = pFast->m_pNext->m_pNext;
            if(pSlow == pFast)
                break;
        }
        if(pFast == NULL || pFast->m_pNext == NULL)
            return NULL;

        // 将环中的此节点作为假设的尾节点，将它变成两个单链表相交问题
        ListNode * pAssumedTail = pSlow;
        ListNode * pHead1 = pHead;
        ListNode * pHead2 = pAssumedTail->m_pNext;

        ListNode * pNode1;
        int len1 = 1;
        ListNode * pNode1 = pHead1;
        while(pNode1 != pAssumedTail)
        {
            pNode1 = pNode1->m_pNext;
            len1++;
        }

        int len2 = 1;
        ListNode * pNode2 = pHead2;
        while(pNode2 != pAssumedTail)
        {
            pNode2 = pNode2->m_pNext;
            len2++;
        }

        pNode1 = pHead1;
        pNode2 = pHead2;
        // 先对齐两个链表的当前结点，使之到尾节点的距离相等
        if(len1 > len2)
        {
            int k = len1 - len2;
            while(k--)
                pNode1 = pNode1->m_pNext;
        }
        else
        {
            int k = len2 - len1;
            while(k--)
                pNode2 = pNode2->m_pNext;
        }
        while(pNode1 != pNode2)
        {
            pNode1 = pNode1->m_pNext;
            pNode2 = pNode2->m_pNext;
        }
        return pNode1;
    }
    ```

10. 删除某一个结点，要求时间复杂度O(1)

    对于删除节点，我们普通的思路就是让该节点的前一个节点指向该节点的下一个节点，这种情况需要遍历找到该节点的前一个节点，时间复杂度为O(n)。  
    对于链表，链表中的每个节点结构都是一样的，所以我们可以把该节点的下一个节点的数据复制到该节点，然后删除下一个节点即可。  
    要注意最后一个节点的情况，这个时候只能用常见的方法来操作，先找到前一个节点，但总体的平均时间复杂度还是O(1)  

    ```
    void Delete(ListNode * pHead, ListNode * pToBeDeleted)
    {
        if(pToBeDeleted == NULL)
            return;
        if(pToBeDeleted->m_pNext != NULL)
        {
            pToBeDeleted->m_nKey = pToBeDeleted->m_pNext->m_nKey; // 将下一个节点的数据复制到本节点，然后删除下一个节点
            ListNode * temp = pToBeDeleted->m_pNext;
            pToBeDeleted->m_pNext = pToBeDeleted->m_pNext->m_pNext;
            delete temp;
        }
        else
        {
            if(pHead == pToBeDeleted) // 链表中只有一个节点的情况
            {
                pHead = NULL;
                delete pToBeDeleted;
            }
            else  // 要删除的是最后一个节点
            {
                ListNode * pNode = pHead;
                while(pNode->m_pNext != pToBeDeleted) // 找到倒数第二个节点
                    pNode = pNode->m_pNext;
                pNode->m_pNext = NULL;
                delete pToBeDeleted;
            }
        }
    }
    ```

11. 去除链表中的重复数字

    [移除链表中的重复元素](https://www.geeksforgeeks.org/remove-duplicates-from-an-unsorted-linked-list)  

    方法一：循环遍历，依次比较，如果相同就删除  
    Time Complexity: O(n^2)  

    ```
    void removeDuplicates(struct Node *start)
    {
        struct Node *ptr1, *ptr2, *dup;
        ptr1 = start;

        /* Pick elements one by one */
        while (ptr1 != NULL && ptr1->next != NULL)
        {
            ptr2 = ptr1;

            /* Compare the picked element with rest
            of the elements */
            while (ptr2->next != NULL)
            {
                /* If duplicate then delete it */
                if (ptr1->data == ptr2->next->data)
                {
                    /* sequence of steps is important here */
                    dup = ptr2->next;
                    ptr2->next = ptr2->next->next;
                    delete(dup);
                }
                else /* This is tricky */
                    ptr2 = ptr2->next;
            }
            ptr1 = ptr1->next;
        } 
    }
    ```

    方法二：用hash表来维护结构体。遍历链表，加入unorder_set，如果set中已经有了该值，就删除。
    We traverse the link list from head to end. For every newly encountered element, we check whether it is in the hash table:  
    if yes, we remove it;  
    otherwise we put it in the hash table.  
    Time Complexity: O(n) on average (assuming that hash table access time is O(1) on average).  

    ```
    /* Function to remove duplicates from a
    unsorted linked list */
    void removeDuplicates(struct Node *start)
    {
        // Hash to store seen values
        unordered_set<int> seen;

        /* Pick elements one by one */
        struct Node *curr = start;
        struct Node *prev = NULL;
        while (curr != NULL)
        {
            // If current value is seen before
            if (seen.find(curr->data) != seen.end())
            {
                prev->next = curr->next;
                delete (curr);
            }
            else
            {
                seen.insert(curr->data);
                prev = curr;
            }
            curr = prev->next;
        }
    }
    ```

    方法三：先排序，再逐个删除。**但是改变了链表原有的顺序。**  
    Time Complexity: O(nLogn)

12. 链表排序

    采用分治法，分开排序，然后合并的方法。  
    合并有序链表在上述问题中有过阐述,时间复杂度为O(max(len1, len2))  
    分治使用快慢指针的方法  

    ```
    ListNode* sortList(ListNode* head) {
        if (head == NULL || head->next ==NULL)
        {
            return head;
        }
        ListNode* slow = head;
        ListNode* fast = head;

        /*快慢指针的用法，fast到结尾，slow到中间*/
        while (fast->next &&fast->next->next)
        {
            fast = fast->next->next;
            slow = slow->next;
        }

        ListNode* rightNode = slow->next;
        slow->next = NULL;
        return mergeList(sortList(head), sortList(rightNode));
    }

    ListNode * mergeList(ListNode* l1, ListNode* l2) {

        ListNode* retListNode = new ListNode(0);
        ListNode* curNode = retListNode;
        while (l1 && l2)
        {
            if (l1->val > l2->val)
            {
                curNode->next = l2;
                l2 = l2->next;
            }
            else
            {
                curNode->next = l1;
                l1 = l1->next;
            }
            curNode = curNode->next;
        }
        if (l1)
        {
            curNode->next = l1;
        }
        else
        {
            curNode->next = l2;
        }
        return retListNode->next;
    }
    ```
13. 删除某个值

    ```
    ListNode* removeElements(ListNode* head, int val) {
        ListNode *pseudo_head = new ListNode(0);
        pseudo_head->next = head;
        ListNode *cur = pseudo_head;
        while(cur){
            if(cur->next && cur->next->val == val)
                cur->next = cur->next->next;
            else
                cur = cur->next;
        }
        return pseudo_head->next;
    }
    ```


#### 二叉树

##### 二叉树的遍历

参考文档：  
    [Binary Tree Postorder Traversal -- LeetCode](https://blog.csdn.net/linhuanmars/article/details/22009351)  
    [Binary Tree Inorder Traversal -- LeetCode](https://blog.csdn.net/linhuanmars/article/details/20187257)  
    [Binary Tree Preorder Traversal -- LeetCode](https://blog.csdn.net/linhuanmars/article/details/21428647)  

1. 先序遍历
    [先序遍历](http://oj.leetcode.com/problems/binary-tree-preorder-traversal/)  
    二叉树的先序遍历我们仍然介绍三种方法，第一种是递归，第二种是迭代方法，第三种是用线索二叉树。  

    **递归**是最简单的方法，算法的时间复杂度是O(n), 而空间复杂度则是递归栈的大小，即O(logn)。  

    ```
    public ArrayList<Integer> preorderTraversal(TreeNode root) {  
        ArrayList<Integer> res = new ArrayList<Integer>();  
        helper(root, res);  
        return res;  
    }  
    private void helper(TreeNode root, ArrayList<Integer> res)  
    {  
        if(root == null)  
            return;  
        res.add(root.val);       /*中结点入list*/
        helper(root.left,res);   /*先左子树*/
        helper(root.right,res);  /*后右子树*/
    }  
    ```

    接下来是**迭代**的做法，其实就是用一个栈来模拟递归的过程。所以算法时间复杂度也是O(n)，空间复杂度是栈的大小O(logn)。  

    ```
    public ArrayList<Integer> preorderTraversal(TreeNode root)
    {
        if(root == null) return res;  
        ArrayList<Integer> res = new ArrayList<Integer>();  
        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();  
        while(root!=null || !stack.isEmpty())  
        {  
            if(root!=null)  
            {  
                stack.push(root);  
                res.add(root.val);  /*根加入list*/
                root = root.left;   /*找左子树，即使为空*/
            }  
            else  
            {  
                root = stack.pop();  /*如果当前结点为空，弹出一个结点（该结点的左子树为空），并找他的右子树*/
                root = root.right;  
            }  
        }  
        return res;  
    }  
    ```

    最后我们介绍一种比较复杂的方法，就是如何用常量空间来遍历一颗二叉树。这种方法叫**Morris Traversal**。想用O(1)空间进行遍历，因为不能用栈作为辅助空间来保存付节点的信息，重点在于当访问到子节点的时候如何重新回到父节点（当然这里是指没有父节点指针，如果有其实就比较好办，**一直找遍历的后驱结点即可**）。Morris遍历方法用了线索二叉树，这个方法不需要为每个节点额外分配指针指向其前驱和后继结点，而是利用叶子节点中的右空指针指向中序遍历下的后继节点就可以了。  

    算法具体分情况如下：  
    2.1 如果当前结点的左孩子为空，则输出当前结点并将其当前节点赋值为右孩子。  
    2.2 如果当前节点的左孩子不为空，则寻找当前节点在中序遍历下的前驱节点（也就是当前结点左子树的最右孩子）。接下来分两种情况：  
        2.2.1 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点（做线索使得稍后可以重新返回父结点）。然后将当前节点更新为当前节点的左孩子。  
        2.2.2 如果前驱节点的右孩子为当前节点，表明左子树已经访问完，可以访问当前节点。将前驱结点的右孩子重新设为空（恢复树的结构）。输出当前节点。当前节点更新为当前节点的右孩子。  

    ```
    public ArrayList<Integer> inorderTraversal(TreeNode root) {
        ArrayList<Integer> res = new ArrayList<Integer>();
        TreeNode cur = root;
        TreeNode pre = null;
        while(cur!=null)
        {
            /*如果当前结点的左子树为空，则输出当前结点，并将当前结点赋值为右子树*/
            if (cur.left == null)
            {
                res.add(cur.val);
                cur = cur.right;
            }
            /*如果当前结点的左子树不为空，则寻找当前结点在“中序遍历”下的前驱结点，也就是当前结点的左子树的最右叶子*/
            else
            {
                pre = cur.left; /*当前结点的左子树*/

                /*左子树的最右叶子,保证不为空，且未遍历过*/
                while(pre.right!=null && pre.right != cur)
                    pre = pre.right;

                /*如果前驱节点的右孩子为空，将前驱结点的右孩子设置为当前节点（做线索使得稍后可以重新返回父结点）。  
                  然后将当前节点更新为当前节点的左孩子。*/  
                if(pre.right == null)
                {
                    pre.right = cur;
                    res.add(cur.val);
                    cur = pre.left;
                }
                /*如果前驱节点的右孩子为当前节点，表明左子树已经访问完，可以访问当前节点。将它的右孩子重新设为空（恢复树的结构）。  
                  输出当前节点。当前节点更新为当前节点的右孩子。*/  
                else
                {
                    pre.right = null;
                    cur = cur.right;
                }
            }
        }
        return res;
    }

    ```


2. 中序遍历
    [中序遍历](http://oj.leetcode.com/problems/binary-tree-inorder-traversal/)  
    通常，实现二叉树的遍历有两个常用的方法：一是用递归，二是使用栈实现的迭代方法。下面分别介绍。  

    **递归**应该最常用的算法，算法的时间复杂度是O(n), 而空间复杂度则是递归栈的大小，即O(logn)。  

    ```
    public ArrayList<Integer> inorderTraversal(TreeNode root) {  
        ArrayList<Integer> res = new ArrayList<Integer>();  
        helper(root, res);  
        return res;  
    }  
    private void helper(TreeNode root, ArrayList<Integer> res)  
    {  
        if(root == null)  
            return;  
        helper(root.left,res);   /*先左子树*/
        res.add(root.val);       /*中结点入list*/
        helper(root.right,res);  /*后右子树*/
    }  
    ```

    **栈实现迭代**，其实就是用一个栈来模拟递归的过程。所以算法时间复杂度也是O(n)，空间复杂度是栈的大小O(logn)。
    过程中维护一个node表示当前走到的结点（不是中序遍历的那个结点），实现的代码如下：

    ```
    public ArrayList<Integer> inorderTraversal(TreeNode root)
    {  
        ArrayList<Integer> res = new ArrayList<Integer>();  
        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();  

        while(root!=null || !stack.isEmpty())  
        {  
            /*找到最左边的子结点*/
            if(root!=null)  
            {  
                stack.push(root);  
                root = root.left;  
            }  
            else  
            {  
                root = stack.pop();  
                res.add(root.val);  
                root = root.right;  
            }  
        }  
        return res;  
    }  
    ```

    最后我们介绍一种比较复杂的方法，就是如何用常量空间来中序遍历一颗二叉树。这种方法叫**Morris Traversal**。想用O(1)空间进行遍历，因为不能用栈作为辅助空间来保存付节点的信息，重点在于当访问到子节点的时候如何重新回到父节点（当然这里是指没有父节点指针，如果有其实就比较好办，一直找遍历的后驱结点即可）。Morris遍历方法用了线索二叉树，这个方法不需要为每个节点额外分配指针指向其前驱和后继结点，而是利用叶子节点中的右空指针指向中序遍历下的后继节点就可以了。  

    算法具体分情况如下：  
    2.1 如果当前结点的左孩子为空，则输出当前结点,并将其当前节点赋值为右孩子。  
    2.2 如果当前节点的左孩子不为空，则寻找当前节点在中序遍历下的前驱节点（也就是当前结点左子树的最右孩子）。接下来分两种情况：  
        2.2.1 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点（做线索使得稍后可以重新返回父结点）。然后将当前节点更新为当前节点的左孩子。  
        2.2.2 如果前驱节点的右孩子为当前节点，表明左子树已经访问完，可以访问当前节点。将前驱结点的右孩子重新设为空（恢复树的结构）。输出当前节点。当前节点更新为当前节点的右孩子。  

    ```
    public ArrayList<Integer> inorderTraversal(TreeNode root) {
        ArrayList<Integer> res = new ArrayList<Integer>();
        TreeNode cur = root;
        TreeNode pre = null;
        while(cur!=null)
        {
            /*如果当前结点的左子树为空，则输出当前结点，并将当前结点赋值为右子树*/
            if (cur.left == null)
            {
                res.add(cur.val);
                cur = cur.right;
            }
            /*如果当前结点的左子树不为空，则寻找当前结点在“中序遍历”下的前驱结点，也就是当前结点的左子树的最右叶子*/
            else
            {
                pre = cur.left; /*当前结点的左子树*/
                /*左子树的最右叶子,保证不为空，且未遍历过*/
                while(pre.right!=null && pre.right != cur)
                    pre = pre.right;
                /*如果前驱节点的右孩子为空，将前驱结点的右孩子设置为当前节点（做线索使得稍后可以重新返回父结点）。  
                  然后将当前节点更新为当前节点的左孩子。*/  
                if(pre.right == null)
                {
                    pre.right = cur;
                    cur = pre.left;
                }
                /*如果前驱节点的右孩子为当前节点，表明左子树已经访问完，可以访问当前节点。将它的右孩子重新设为空（恢复树的结构）。  
                  输出当前节点。当前节点更新为当前节点的右孩子。*/  
                else
                {
                    pre.right = null;
                    res.add(cur.val);
                    cur = cur.right;
                }
            }
        }
        return res;
    }

    ```

3. 后序遍历

    [后序遍历](http://oj.leetcode.com/problems/binary-tree-postorder-traversal/ )

    后序遍历我们还是介绍三种方法，第一种是递归，第二种是迭代方法，第三种是用线索二叉树。  
    递归算法的时间复杂度是O(n), 而空间复杂度则是递归栈的大小，即O(logn)。  

    ```
    public ArrayList<Integer> postorderTraversal(TreeNode root) {  
        ArrayList<Integer> res = new ArrayList<Integer>();  
        helper(root, res);  
        return res;  
    }  
    private void helper(TreeNode root, ArrayList<Integer> res)  
    {  
        if(root == null)  
            return;  
        helper(root.left,res);   /*左子树递归*/
        helper(root.right,res);  /*右子树递归*/
        res.add(root.val);       /*根节点加入*/
    }  
    ```

    后来再看wiki的时候发现有跟中序遍历和先序遍历非常类似的解法，容易统一进行记忆，思路可以参考其他两种，区别是最下面在弹栈的时候需要分情况一下：
    + 如果当前栈顶元素的右结点存在并且还没访问过（也就是右结点不等于上一个访问结点），那么就把当前结点移到右结点继续循环；
    + 如果栈顶元素的右子树是空或者已经访问过，那么说明栈顶元素的左右子树都访问完毕，应该访问自己继续回溯了。

    ```
    public List<Integer> postorderTraversal(TreeNode root) {  
        List<Integer> res = new ArrayList<Integer>();  
        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();  
        if(root == null)  
        {  
            return res;  
        }  
        TreeNode pre = null;  /*记录右结点是否访问过*/
        while(root != null || !stack.isEmpty())  
        {  
            if(root!=null)  
            {  
                stack.push(root);  
                root = root.left;  /*找到最左边的树结点*/
            }  
            else  
            {  
                TreeNode peekNode = stack.peek();  /*栈顶元素*/
                if(peekNode.right != null && pre != peekNode.right)  
                {  
                    root = peekNode.right;  
                }  
                else  
                {  
                    stack.pop();  
                    res.add(peekNode.val);  
                    pre = peekNode;  
                }  
            }  
        }  
        return res;  
    }  
    ```

4. 层级遍历

    用队列来维护.算法的复杂度是就结点的数量:O(n)，空间复杂度是一层的结点数:O(n)。  

    ```
    vector<int> PrintFromTopToBottom(TreeNode* root)
    {
        vector<int> vRet;
        queue<TreeNode*> queTree;

        if(root == nullptr) return vRet;
        queTree.push(root);

        while(!queTree.empty())
        {
            /*队列先进先出，进入vector*/
            TreeNode *tmp = queTree.front();
            vRet.push_back(tmp->val);
            /*左右子树入队列*/
            if(tmp->left != nullptr) {
                queTree.push(tmp->left);
            }
            if(tmp->right != nullptr) {
                queTree.push(tmp->right);
            }
            /*出队*/
            queTree.pop();
        }
        return vRet;
    }
    ```


#### 二叉树的操作

1. 二叉树镜像
    操作给定的二叉树，将其变换为源二叉树的镜像。也就是左子树转右子树。  

    ```
    void Mirror(TreeNode *pRoot) {
        if(pRoot == nullptr) return;

        //swap
        TreeNode *tmp = pRoot->left;
        pRoot->left = pRoot->right;
        pRoot->right = tmp;

        //递归左右
        Mirror(pRoot->left);
        Mirror(pRoot->right);
    }
    ```

2. 二叉树深度

    输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。  

    ```
    int TreeDepth(TreeNode* pRoot)
    {
        if(pRoot==nullptr) return 0;
        return max(1+TreeDepth(pRoot->left),1+TreeDepth(pRoot->right));
    }
    ```

3. 对称树判断

    是否对称树

    ```
    boolean isSymmetrical(TreeNode pRoot)
    {
        return judge(pRoot,pRoot);
    }

    public boolean judge(TreeNode pRoot,TreeNode root){
        if(pRoot== null && root == null){
            return true;
        }
        if(pRoot==null || root == null){
            return false;
        }
        if(pRoot.val != root.val)
            return false;
        return judge(pRoot.left,root.right) && judge(pRoot.right,root.left);
    }
    ```

4. 平衡树的判断
   
    输入一颗二叉树判断是否为平衡树

    + 方法一：
    ```
   public class Solution {
        public boolean IsBalanced_Solution(TreeNode root) {
            if (root == null)
                return true;
            int left = TreeDepth(root.left);
            int right = TreeDepth(root.right);
            if (Math.abs(left-right) <= 1)
                return IsBalanced_Solution(root.left) && IsBalanced_Solution(root.right);
            else
                return false;
        }

        private int TreeDepth(TreeNode root) {
            if (root == null)
                return 0;
            int left = TreeDepth(root.left)+1;
            int right = TreeDepth(root.right)+1;
            return Math.max((1 + TreeDepth(root.left)), (1 + TreeDepth(root.right)));
        }
    }
    ```

   + 方法二：-1代表不平衡，有个子树不平衡那么整个树肯定不平衡  
    ```
    class Solution {
    public:
        bool IsBalanced_Solution(TreeNode* pRoot) {
            return getDepth(pRoot) != -1;
        }
        int getDepth(TreeNode* pRoot)
        {
            if (pRoot == nullptr) return 0;
            int left = getDepth(pRoot->left);
            if (left == -1) return -1;
            int right = getDepth(pRoot->right);
            if (right == -1) return -1;
            return abs(left - right) > 1 ? -1 : 1 + max(left, right);
        }
    };
    ```


5. 二叉树转链表

    输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。  
    要求不能创建任何新的结点，只能调整树中结点指针的指向。  

    ```
    class Solution {
    public:
        TreeNode* Convert(TreeNode* pRootofTree)
        {
            if(pRootofTree == nullptr) return nullptr;
            TreeNode* pre = nullptr;
            helper(pRootofTree,pre);

            TreeNode* result = pRootofTree;

            while(result->left)
            {
                result = result->left;
            }
            return result;
        }
        void helper(TreeNode* pRootofTree,TreeNode*& pre)
        {
            if(pRootofTree == nullptr) return;
            helper(pRootofTree->left, pre);

            pRootofTree->left = pre;

            if(pre) pre->right = pRootofTree;

            pre = pRootofTree;

            helper(pRootofTree->right, pre);
        }
    };
    ```

6. BST中第K大的数

    [查找二叉平衡树中第 K 大的元素](https://www.geeksforgeeks.org/kth-largest-element-in-bst-when-modification-to-bst-is-not-allowed/)  

    Binary Search Tree是有序的，先找最右，当数字小于K的时候，再逐步找左子树。  
    时间复杂度：O(h + k). The code first traverses down to the rightmost node which takes O(h) time, then traverses k elements in O(k) time.  

    ```
    // A function to find k'th largest element in a given tree.
    void kthLargestUtil(Node *root, int k, int &c)
    {
        // Base cases, the second condition is important to
        // avoid unnecessary recursive calls
        if (root == NULL || c >= k)
            return;

        // Follow reverse inorder traversal so that the
        // largest element is visited first
        kthLargestUtil(root->right, k, c);

        // Increment count of visited nodes 
        c++;

        // If c becomes k now, then this is the k'th largest  
        if (c == k)
        {
            cout << "K'th largest element is "
                << root->key << endl;
            return;
        }

        // Recur for left subtree
        kthLargestUtil(root->left, k, c);
    }

    // Function to find k'th largest element
    void kthLargest(Node *root, int k)
    {
        // Initialize count of nodes visited as 0
        int c = 0;

        // Note that c is passed by reference
        kthLargestUtil(root, k, c);
    }
    ```

7. 打印和根节点距离为K的结点

    [查找树中与根节点距离为 k 的节点](https://www.geeksforgeeks.org/print-nodes-at-k-distance-from-root)

    空间复杂度： O(n) where n is number of nodes in the given binary tree.

    ```
    void printKDistant(node *root , int k)  
    {  
        if(root == NULL)  
            return;  
        if( k == 0 )  
        {  
            cout << root->data << " ";  
            return ;  
        }  
        else
        {  
            printKDistant( root->left, k - 1 ) ;  
            printKDistant( root->right, k - 1 ) ;  
        }  
    }  
    ```

8. 打印所有祖先节点

    [查找二叉树中某个节点所有祖先节点](https://www.geeksforgeeks.org/print-ancestors-of-a-given-node-in-binary-tree)

    时间复杂度：Time Complexity: O(n) . where n is the number of nodes in the given Binary Tree

    ```
    /* If target is present in tree, then prints the ancestors
    and returns true, otherwise returns false. */
    bool printAncestors(struct node *root, int target)
    {
        /* base cases */
        if (root == NULL)
            return false;

        if (root->data == target)
            return true;

        /* If target is present in either left or right subtree of this node,
            then print this node */
        if ( printAncestors(root->left, target) ||
            printAncestors(root->right, target) )
        {
            cout << root->data << " ";
            return true;
        }

        /* Else return false */
        return false;
    }
    ```

9. 是否是Binary Search Tree

    每当遍历到一个新节点时和其上一个节点比较，如果不大于上一个节点那么则返回false，全部遍历完成后返回true  

    ```
    bool isValidBST(TreeNode* root) {
        TreeNode *tmpNode = NULL;
        return helper(root, tmpNode);
    }
    bool helper(TreeNode* root, TreeNode* &tmpNode)
    {
        /*中序遍历，只比较判断，不进行其他处理*/
        if (root == NULL)
        {
            return true;
        }
        bool left = helper(root->left, tmpNode);
        if (tmpNode != NULL && tmpNode->val >= root->val)
        {
            return false;
        }
        tmpNode = root;
        return left && helper(root->right, tmpNode);
    }
    ```
10. 路径求和

    ```
    bool hasPathSum(TreeNode* root, int sum) {
        if (NULL == root) return false;
        if (root->left==NULL && root->right==NULL && root->val==sum) return true;
        return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);
    }
    ```

    问题变化：记录路径结点。

    ```
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        vector<vector<int>> ret;
        if(root==NULL) return ret;
        vector<int>item;
        helper(root, sum, item, ret);  
        return ret;
    }
    void helper(TreeNode* root, int sum, vector<int>& item, vector<vector<int>>& ret)
    {
        if(root==NULL) return;
        item.push_back(root->val);
        if(root->right==NULL&&root->left==NULL&& sum ==root->val)
        {
            ret.push_back(item);
        }
        helper(root->left, sum-root->val, item, ret);
        helper(root->right, sum-root->val, item, ret);

        //作为静态变量存储需要恢复现场
        item.pop_back();//很关键
    }
    ```

#### string

1. 二叉树转字符串

    ```
    string tree2str(TreeNode* t)
    {
        if(!t) return "";

        string s = to_string(t->val);                    //root
        if(t->left) 
            s += "(" + tree2str(t->left) + ")";          //left
        else if(t->right) //左为空，加括号注明其为空
            s += "()";

        if(t->right) 
            s += "(" + tree2str(t->right) + ")";        //right
        return s;
    }
    ```


### 算法

#### 排序算法总结

排序是经常会考到的算法。各大排序算法总结：  

排序算法 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性
---|---|---|---|---
[冒泡排序](./Algorithm/BubbleSort.cpp) | O(n<sup>2</sup>)      | O(n<sup>2</sup>)      | O(1)                |稳定
[选择排序](./Algorithm/SelectSort.cpp) | O(n<sup>2</sup>)      | O(n<sup>2</sup>)      | O(1)                |数组不稳定、链表稳定
[插入排序](./Algorithm/InsertSort.cpp) | O(n<sup>2</sup>)      | O(n<sup>2</sup>)      | O(1)                |稳定
[快速排序](./Algorithm/QuickSort.cpp)  | O(n*log<sub>2</sub>n) | O(n<sup>2</sup>)      | O(log<sub>2</sub>n) | 不稳定
[堆排序](./Algorithm/HeapSort.cpp)     | O(n*log<sub>2</sub>n) | O(n*log<sub>2</sub>n) | O(1)                | 不稳定
[归并排序](./Algorithm/MergeSort.cpp)  | O(n*log<sub>2</sub>n) | O(n*log<sub>2</sub>n) | O(n)                | 稳定
[希尔排序](./Algorithm/ShellSort.cpp)  | O(n*log<sup>2</sup>n) |O(n<sup>2</sup>)       | O(1)                | 不稳定


#### 查找算法

    查找算法有递归和非递归两种写法。不过都是从中间进行分开，分别查找的方法，或者逐步逼近的思路  

    ```
    class CSearch
    {
    public:
        /*递归方法*/
        int recursionHelper(int arr[], int value, int low, int high) 
        {
            /*当有多个相同的值的时候，得到的下标不一样*/
            /*插入查找法*/
            //int mid = low + (value - arr[low]) / (arr[high] - arr[low])*(high - low);
            if (low>high)
            {
                return -1;
            }
            /*一般查找法*/
            int mid = low + (high - low) / 2;

            if (arr[mid] == value)
                return mid;
            if (arr[mid] > value)
                return recursionHelper(arr, value, low, mid - 1);
            if (arr[mid] < value)
                return recursionHelper(arr, value, mid + 1, high);
        }
        int commonHelper(int arr[], int value, int low, int high) 
        {
            while (low <= high)
            {
                int mid = low + (high - low) / 2;
                if (arr[mid] == value)
                {
                    return mid;
                }
                else if (arr[mid] < value)
                {
                    low = mid + 1;
                }
                else
                {
                    high = mid - 1;
                }
            }
            /*没有找到*/
            if (low > high)
            {
                return -1;
            }
        }
        /*有序数组*/
        int BinarySearch(int arr[], int length, int value)
        {
            if (arr == NULL || length == 0) return -1;
            int low = 0;
            int high = length - 1;
            int ret = commonHelper(arr, value, low, high);
            ret = ret > 0 ? ret+1 : -1;
            return ret;
        }

    private:
    };
    ```

#### hash算法

#### 一些复杂算法

    贪心算法，分治算法，动态规划算法，随机划分算法，回溯算法等。掌握设计思想  

1. 约瑟夫问题

    f [1] = 0;  
    f [ i ] = ( f [i -1] + m) % i; (i>1)  

    ```
    int josephus(int n, int k) 
    { 
        //非迭代版本
        int s = 0;
        for (int i = 2; i <= n; i++)
        {
            s = (s + k) % i;
        }
        return s;
    }
    int josephus_recursion(int n, int k) 
    { 
        //迭代版本
        return n > 0 ? (josephus_recursion(n - 1, k) + k) % n : 0;
    }
    ```

2. 青蛙跳

    问题一：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

    ```
    class Solution {
    public:
        int jumpFloorII(int number) {
            /*
            每层台阶有跳或者不跳两种选择，就是2，N层就是2的N-1次方，因为最后一次必须跳
            */
            return 1<<(number-1);
        }
    };
    ```

    问题二：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。  

    ```
    class Solution {
    public:
        int jumpFloor(int number) {
            
            /*递归方法*/
            /*
            int fn1 = 1;
            int fn2 =2;
            if(number<1)
                return 0;
            if(number == 1)
                return fn1;
            if(number == 2)
                return fn2;

            return jumpFloor(number-1)+jumpFloor(number-2);
            */
            //使用迭代法，用fn1和fn2保存计算过程中的结果，并复用起来
            int fn1 = 1;
            int fn2 = 2;

            //考虑出错情况
            if (number < 1) {
                return 0;
            }
            //第一和第二个数直接返回
            if(number == 1)
                return fn1;
            if(number == 2)
                return fn2;

            while (number-- > 2) {
                int temp = fn2;
                fn2 = fn1 + fn2;
                fn1 = temp;
            }
            return fn2;
            /*
            int total=0;
            for(int i=2;i<number;i++){
                total=fn1+fn2;
                fn1=fn2;
                fn2=total;  
            }
            return total;
            */
        }
    };
    ```

#### STL
