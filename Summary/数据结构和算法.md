### 数据结构

#### 链表

#### 二叉树

##### 二叉树的遍历

参考文档：  
    [Binary Tree Postorder Traversal -- LeetCode](https://blog.csdn.net/linhuanmars/article/details/22009351)  
    [Binary Tree Inorder Traversal -- LeetCode](https://blog.csdn.net/linhuanmars/article/details/20187257)  
    [Binary Tree Preorder Traversal -- LeetCode](https://blog.csdn.net/linhuanmars/article/details/21428647)  

1. 先序遍历
    [先序遍历](http://oj.leetcode.com/problems/binary-tree-preorder-traversal/)  
    二叉树的先序遍历我们仍然介绍三种方法，第一种是递归，第二种是迭代方法，第三种是用线索二叉树。  

    **递归**是最简单的方法，算法的时间复杂度是O(n), 而空间复杂度则是递归栈的大小，即O(logn)。  

    ```
    public ArrayList<Integer> preorderTraversal(TreeNode root) {  
        ArrayList<Integer> res = new ArrayList<Integer>();  
        helper(root, res);  
        return res;  
    }  
    private void helper(TreeNode root, ArrayList<Integer> res)  
    {  
        if(root == null)  
            return;  
        res.add(root.val);       /*中结点入list*/
        helper(root.left,res);   /*先左子树*/
        helper(root.right,res);  /*后右子树*/
    }  
    ```

    接下来是**迭代**的做法，其实就是用一个栈来模拟递归的过程。所以算法时间复杂度也是O(n)，空间复杂度是栈的大小O(logn)。  

    ```
    public ArrayList<Integer> preorderTraversal(TreeNode root)
    {
        if(root == null) return res;  
        ArrayList<Integer> res = new ArrayList<Integer>();  
        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();  
        while(root!=null || !stack.isEmpty())  
        {  
            if(root!=null)  
            {  
                stack.push(root);  
                res.add(root.val);  /*根加入list*/
                root = root.left;   /*找左子树，即使为空*/
            }  
            else  
            {  
                root = stack.pop();  /*如果当前结点为空，弹出一个结点（该结点的左子树为空），并找他的右子树*/
                root = root.right;  
            }  
        }  
        return res;  
    }  
    ```

    最后我们介绍一种比较复杂的方法，就是如何用常量空间来遍历一颗二叉树。这种方法叫**Morris Traversal**。想用O(1)空间进行遍历，因为不能用栈作为辅助空间来保存付节点的信息，重点在于当访问到子节点的时候如何重新回到父节点（当然这里是指没有父节点指针，如果有其实就比较好办，**一直找遍历的后驱结点即可**）。Morris遍历方法用了线索二叉树，这个方法不需要为每个节点额外分配指针指向其前驱和后继结点，而是利用叶子节点中的右空指针指向中序遍历下的后继节点就可以了。
    算法具体分情况如下：  
    2.1 如果当前结点的左孩子为空，则输出当前结点并将其当前节点赋值为右孩子。  
    2.2 如果当前节点的左孩子不为空，则寻找当前节点在中序遍历下的前驱节点（也就是当前结点左子树的最右孩子）。接下来分两种情况：  
        2.2.1 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点（做线索使得稍后可以重新返回父结点）。然后将当前节点更新为当前节点的左孩子。  
        2.2.2 如果前驱节点的右孩子为当前节点，表明左子树已经访问完，可以访问当前节点。将前驱结点的右孩子重新设为空（恢复树的结构）。输出当前节点。当前节点更新为当前节点的右孩子。  

    ```
    public ArrayList<Integer> inorderTraversal(TreeNode root) {
        ArrayList<Integer> res = new ArrayList<Integer>();
        TreeNode cur = root;
        TreeNode pre = null;
        while(cur!=null)
        {
            /*如果当前结点的左子树为空，则输出当前结点，并将当前结点赋值为右子树*/
            if (cur.left == null)
            {
                res.add(cur.val);
                cur = cur.right;
            }
            /*如果当前结点的左子树不为空，则寻找当前结点在“中序遍历”下的前驱结点，也就是当前结点的左子树的最右叶子*/
            else
            {
                pre = cur.left; /*当前结点的左子树*/
                /*左子树的最右叶子,保证不为空，且未遍历过*/

                while(pre.right!=null && pre.right != cur)
                    pre = pre.right;

                /*如果前驱节点的右孩子为空，将前驱结点的右孩子设置为当前节点（做线索使得稍后可以重新返回父结点）。  
                  然后将当前节点更新为当前节点的左孩子。*/  
                if(pre.right == null)
                {
                    pre.right = cur;
                    res.add(cur.val);
                    cur = pre.left;
                }
                /*如果前驱节点的右孩子为当前节点，表明左子树已经访问完，可以访问当前节点。将它的右孩子重新设为空（恢复树的结构）。  
                  输出当前节点。当前节点更新为当前节点的右孩子。*/  
                else
                {
                    pre.right = null;
                    cur = cur.right;
                }
            }
        }
        return res;
    }

    ```


2. 中序遍历
    [中序遍历](http://oj.leetcode.com/problems/binary-tree-inorder-traversal/)  
    通常，实现二叉树的遍历有两个常用的方法：一是用递归，二是使用栈实现的迭代方法。下面分别介绍。  

    **递归**应该最常用的算法，算法的时间复杂度是O(n), 而空间复杂度则是递归栈的大小，即O(logn)。  

    ```
    public ArrayList<Integer> inorderTraversal(TreeNode root) {  
        ArrayList<Integer> res = new ArrayList<Integer>();  
        helper(root, res);  
        return res;  
    }  
    private void helper(TreeNode root, ArrayList<Integer> res)  
    {  
        if(root == null)  
            return;  
        helper(root.left,res);   /*先左子树*/
        res.add(root.val);       /*中结点入list*/
        helper(root.right,res);  /*后右子树*/
    }  
    ```

    **栈实现迭代**，其实就是用一个栈来模拟递归的过程。所以算法时间复杂度也是O(n)，空间复杂度是栈的大小O(logn)。
    过程中维护一个node表示当前走到的结点（不是中序遍历的那个结点），实现的代码如下：

    ```
    public ArrayList<Integer> inorderTraversal(TreeNode root)
    {  
        ArrayList<Integer> res = new ArrayList<Integer>();  
        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();  

        while(root!=null || !stack.isEmpty())  
        {  
            /*找到最左边的子结点*/
            if(root!=null)  
            {  
                stack.push(root);  
                root = root.left;  
            }  
            else  
            {  
                root = stack.pop();  
                res.add(root.val);  
                root = root.right;  
            }  
        }  
        return res;  
    }  
    ```

    最后我们介绍一种比较复杂的方法，就是如何用常量空间来中序遍历一颗二叉树。这种方法叫**Morris Traversal**。想用O(1)空间进行遍历，因为不能用栈作为辅助空间来保存付节点的信息，重点在于当访问到子节点的时候如何重新回到父节点（当然这里是指没有父节点指针，如果有其实就比较好办，一直找遍历的后驱结点即可）。Morris遍历方法用了线索二叉树，这个方法不需要为每个节点额外分配指针指向其前驱和后继结点，而是利用叶子节点中的右空指针指向中序遍历下的后继节点就可以了。
    算法具体分情况如下：  
    2.1 如果当前结点的左孩子为空，则输出当前结点并将其当前节点赋值为右孩子。  
    2.2 如果当前节点的左孩子不为空，则寻找当前节点在中序遍历下的前驱节点（也就是当前结点左子树的最右孩子）。接下来分两种情况：  
        2.2.1 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点（做线索使得稍后可以重新返回父结点）。然后将当前节点更新为当前节点的左孩子。  
        2.2.2 如果前驱节点的右孩子为当前节点，表明左子树已经访问完，可以访问当前节点。将前驱结点的右孩子重新设为空（恢复树的结构）。输出当前节点。当前节点更新为当前节点的右孩子。  

    ```
    public ArrayList<Integer> inorderTraversal(TreeNode root) {
        ArrayList<Integer> res = new ArrayList<Integer>();
        TreeNode cur = root;
        TreeNode pre = null;
        while(cur!=null)
        {
            /*如果当前结点的左子树为空，则输出当前结点，并将当前结点赋值为右子树*/
            if (cur.left == null)
            {
                res.add(cur.val);
                cur = cur.right;
            }
            /*如果当前结点的左子树不为空，则寻找当前结点在“中序遍历”下的前驱结点，也就是当前结点的左子树的最右叶子*/
            else
            {
                pre = cur.left; /*当前结点的左子树*/
                /*左子树的最右叶子,保证不为空，且未遍历过*/
                while(pre.right!=null && pre.right != cur)
                    pre = pre.right;
                /*如果前驱节点的右孩子为空，将前驱结点的右孩子设置为当前节点（做线索使得稍后可以重新返回父结点）。  
                  然后将当前节点更新为当前节点的左孩子。*/  
                if(pre.right == null)
                {
                    pre.right = cur;
                    cur = pre.left;
                }
                /*如果前驱节点的右孩子为当前节点，表明左子树已经访问完，可以访问当前节点。将它的右孩子重新设为空（恢复树的结构）。  
                  输出当前节点。当前节点更新为当前节点的右孩子。*/  
                else
                {
                    pre.right = null;
                    res.add(cur.val);
                    cur = cur.right;
                }
            }
        }
        return res;
    }

    ```

3. 后序遍历

    [后序遍历](原题链接: http://oj.leetcode.com/problems/binary-tree-postorder-traversal/ )

    后序遍历我们还是介绍三种方法，第一种是递归，第二种是迭代方法，第三种是用线索二叉树。  
    递归算法的时间复杂度是O(n), 而空间复杂度则是递归栈的大小，即O(logn)。  

    ```
    public ArrayList<Integer> postorderTraversal(TreeNode root) {  
        ArrayList<Integer> res = new ArrayList<Integer>();  
        helper(root, res);  
        return res;  
    }  
    private void helper(TreeNode root, ArrayList<Integer> res)  
    {  
        if(root == null)  
            return;  
        helper(root.left,res);   /*左子树递归*/
        helper(root.right,res);  /*右子树递归*/
        res.add(root.val);       /*根节点加入*/
    }  
    ```

    后来再看wiki的时候发现有跟中序遍历和先序遍历非常类似的解法，容易统一进行记忆，思路可以参考其他两种，区别是最下面在弹栈的时候需要分情况一下：
    + 如果当前栈顶元素的右结点存在并且还没访问过（也就是右结点不等于上一个访问结点），那么就把当前结点移到右结点继续循环；
    + 如果栈顶元素的右子树是空或者已经访问过，那么说明栈顶元素的左右子树都访问完毕，应该访问自己继续回溯了。

    ```
    public List<Integer> postorderTraversal(TreeNode root) {  
        List<Integer> res = new ArrayList<Integer>();  
        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();  
        if(root == null)  
        {  
            return res;  
        }  
        TreeNode pre = null;  /*记录右结点是否访问过*/
        while(root != null || !stack.isEmpty())  
        {  
            if(root!=null)  
            {  
                stack.push(root);  
                root = root.left;  /*找到最左边的树结点*/
            }  
            else  
            {  
                TreeNode peekNode = stack.peek();  /*栈顶元素*/
                if(peekNode.right != null && pre != peekNode.right)  
                {  
                    root = peekNode.right;  
                }  
                else  
                {  
                    stack.pop();  
                    res.add(peekNode.val);  
                    pre = peekNode;  
                }  
            }  
        }  
        return res;  
    }  
    ```

4. 层级遍历

    用队列来维护.算法的复杂度是就结点的数量:O(n)，空间复杂度是一层的结点数:O(n)。  

    ```
    vector<int> PrintFromTopToBottom(TreeNode* root)
    {
        vector<int> vRet;
        queue<TreeNode*> queTree;

        if(root == nullptr) return vRet;
        queTree.push(root);

        while(!queTree.empty())
        {
            /*队列先进先出，进入vector*/
            TreeNode *tmp = queTree.front();
            vRet.push_back(tmp->val);
            /*左右子树入队列*/
            if(tmp->left != nullptr) {
                queTree.push(tmp->left);
            }
            if(tmp->right != nullptr) {
                queTree.push(tmp->right);
            }
            /*出队*/
            queTree.pop();
        }
        return vRet;
    }
    ```


#### 二叉树的操作

1. 二叉树镜像
    操作给定的二叉树，将其变换为源二叉树的镜像。也就是左子树转右子树。  

    ```
    void Mirror(TreeNode *pRoot) {
        if(pRoot == nullptr) return;

        //swap
        TreeNode *tmp = pRoot->left;
        pRoot->left = pRoot->right;
        pRoot->right = tmp;

        //递归左右
        Mirror(pRoot->left);
        Mirror(pRoot->right);
    }
    ```

2. 二叉树深度

    输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。  

    ```
    int TreeDepth(TreeNode* pRoot)
    {
        if(pRoot==nullptr) return 0;
        return max(1+TreeDepth(pRoot->left),1+TreeDepth(pRoot->right));
    }
    ```

3. 对称树判断

    是否对称树

    ```
    boolean isSymmetrical(TreeNode pRoot)
    {
        return judge(pRoot,pRoot);
    }

    public boolean judge(TreeNode pRoot,TreeNode root){
        if(pRoot== null && root == null){
            return true;
        }
        if(pRoot==null || root == null){
            return false;
        }
        if(pRoot.val != root.val)
            return false;
        return judge(pRoot.left,root.right) && judge(pRoot.right,root.left);
    }
    ```

4. 平衡树的判断
   
    输入一颗二叉树判断是否为平衡树

    + 方法一：
    ```
   public class Solution {
        public boolean IsBalanced_Solution(TreeNode root) {
            if (root == null)
                return true;
            int left = TreeDepth(root.left);
            int right = TreeDepth(root.right);
            if (Math.abs(left-right) <= 1)
                return IsBalanced_Solution(root.left) && IsBalanced_Solution(root.right);
            else
                return false;
        }

        private int TreeDepth(TreeNode root) {
            if (root == null)
                return 0;
            int left = TreeDepth(root.left)+1;
            int right = TreeDepth(root.right)+1;
            return Math.max((1 + TreeDepth(root.left)), (1 + TreeDepth(root.right)));
        }
    }
    ```

   + 方法二：-1代表不平衡，有个子树不平衡那么整个树肯定不平衡  
    ```
    class Solution {
    public:
        bool IsBalanced_Solution(TreeNode* pRoot) {
            return getDepth(pRoot) != -1;
        }
        int getDepth(TreeNode* pRoot)
        {
            if (pRoot == nullptr) return 0;
            int left = getDepth(pRoot->left);
            if (left == -1) return -1;
            int right = getDepth(pRoot->right);
            if (right == -1) return -1;
            return abs(left - right) > 1 ? -1 : 1 + max(left, right);
        }
    };
    ```









5. 二叉树转链表

    输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。  
    要求不能创建任何新的结点，只能调整树中结点指针的指向。  

    ```
    class Solution {
    public:
        TreeNode* Convert(TreeNode* pRootofTree)
        {
            if(pRootofTree == nullptr) return nullptr;
            TreeNode* pre = nullptr;
            helper(pRootofTree,pre);
            
            TreeNode* result = pRootofTree;
            
            while(result->left)
            {
                result = result->left;
            }
            return result;
        }
        void helper(TreeNode* pRootofTree,TreeNode*& pre)
        {
            if(pRootofTree == nullptr) return;
            helper(pRootofTree->left, pre);
            
            pRootofTree->left = pre;
            
            if(pre) pre->right = pRootofTree;
            
            pre = pRootofTree;
            
            helper(pRootofTree->right, pre);
        }
    };
    ```


### 算法

#### 排序算法总结

排序是经常会考到的算法。各大排序算法总结：  

排序算法 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性
---|---|---|---|---
[冒泡排序](./Algorithm/BubbleSort.cpp) | O(n<sup>2</sup>)      | O(n<sup>2</sup>)      | O(1)                |稳定
[选择排序](./Algorithm/SelectSort.cpp) | O(n<sup>2</sup>)      | O(n<sup>2</sup>)      | O(1)                |数组不稳定、链表稳定
[插入排序](./Algorithm/InsertSort.cpp) | O(n<sup>2</sup>)      | O(n<sup>2</sup>)      | O(1)                |稳定
[快速排序](./Algorithm/QuickSort.cpp)  | O(n*log<sub>2</sub>n) | O(n<sup>2</sup>)      | O(log<sub>2</sub>n) | 不稳定
[堆排序](./Algorithm/HeapSort.cpp)     | O(n*log<sub>2</sub>n) | O(n*log<sub>2</sub>n) | O(1)                | 不稳定
[归并排序](./Algorithm/MergeSort.cpp)  | O(n*log<sub>2</sub>n) | O(n*log<sub>2</sub>n) | O(n)                | 稳定
[希尔排序](./Algorithm/ShellSort.cpp)  | O(n*log<sup>2</sup>n) |O(n<sup>2</sup>)       | O(1)                | 不稳定
